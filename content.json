[{"title":"","date":"2018-03-20T15:27:42.519Z","path":"2018/03/20/一个前段数据动态显示的插件/","text":"1234567891011121314151617&lt;span class=\"number-slide\"&gt;&lt;/span&gt;&lt;script&gt;$(function() &#123; var numRun2 = $(\".number-slide\").numberAnimate(&#123; num: '212135', // 初始值 speed: 1000, // 切换速度 symbol: \",\" &#125;); var nums2 = 212135; setInterval(function() &#123; var n = Math.floor(Math.random() * 7 + 1) nums2 += n; console.log(n, nums2) numRun2.resetData(nums2); &#125;, 5000);&#125;);&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435.mt-number-animate &#123; line-height: 100px; height: 100px; font-size: 70px; overflow: hidden; display: inline-block; overflow: hidden; display: inline-block; position: relative; top: 25px; font-family: \"Helvetica35-Thin\";&#125;.mt-number-animate .mt-number-animate-dot &#123; width: 30px; line-height: 100px; float: left; text-align: center&#125;.mt-number-animate .mt-number-animate-dom &#123; width: 50px; text-align: center; float: left; position: relative; top: 0; font-family: \"Helvetica35-Thin\"; font-weight: 100&#125;.mt-number-animate .mt-number-animate-dom .mt-number-animate-span &#123; width: 100%; float: left&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130;(function($) &#123; $.fn.numberAnimate = function(setting) &#123; var defaults = &#123; speed: 1000, //动画速度 num: \"\", //初始化值 iniAnimate: true, //是否要初始化动画效果 symbol: '', //默认的分割符号，千，万，千万 dot: 0 //保留几位小数点 &#125; //如果setting为空，就取default的值 var setting = $.extend(defaults, setting); //如果对象有多个，提示出错 if ($(this).length &gt; 1) &#123; alert(\"just only one obj!\"); return; &#125; //如果未设置初始化值。提示出错 if (setting.num == \"\") &#123; alert(\"must set a num!\"); return; &#125; var nHtml = '&lt;div class=\"mt-number-animate-dom\" data-num=\"&#123;&#123;num&#125;&#125;\"&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;0&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;1&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;2&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;3&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;4&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;5&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;6&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;7&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;8&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;9&lt;/span&gt;\\ &lt;span class=\"mt-number-animate-span\"&gt;.&lt;/span&gt;\\ &lt;/div&gt;'; //数字处理 var numToArr = function(num) &#123; num = parseFloat(num).toFixed(setting.dot); if (typeof(num) == 'number') &#123; var arrStr = num.toString().split(\"\"); &#125; else &#123; var arrStr = num.split(\"\"); &#125; //console.log(arrStr); return arrStr; &#125; //设置DOM symbol:分割符号 var setNumDom = function(arrStr) &#123; var shtml = '&lt;div class=\"mt-number-animate\"&gt;'; for (var i = 0, len = arrStr.length; i &lt; len; i++) &#123; if (i != 0 &amp;&amp; (len - i) % 3 == 0 &amp;&amp; setting.symbol != \"\" &amp;&amp; arrStr[i] != \".\") &#123; shtml += '&lt;div class=\"mt-number-animate-dot\"&gt;' + setting.symbol + '&lt;/div&gt;' + nHtml.replace(\"&#123;&#123;num&#125;&#125;\", arrStr[i]); &#125; else &#123; shtml += nHtml.replace(\"&#123;&#123;num&#125;&#125;\", arrStr[i]); &#125; &#125; shtml += '&lt;/div&gt;'; return shtml; &#125; //执行动画 var runAnimate = function($parent) &#123; $parent.find(\".mt-number-animate-dom\").each(function() &#123; var num = $(this).attr(\"data-num\"); num = (num == \".\" ? 10 : num); var spanHei = $(this).height() / 11; //11为元素个数 var thisTop = -num * spanHei + \"px\"; if (thisTop != $(this).css(\"top\")) &#123; if (setting.iniAnimate) &#123; //HTML5不支持 if (!window.applicationCache) &#123; $(this).animate(&#123; top: thisTop &#125;, setting.speed); &#125; else &#123; $(this).css(&#123; 'transform': 'translateY(' + thisTop + ')', '-ms-transform': 'translateY(' + thisTop + ')', /* IE 9 */ '-moz-transform': 'translateY(' + thisTop + ')', /* Firefox */ '-webkit-transform': 'translateY(' + thisTop + ')', /* Safari 和 Chrome */ '-o-transform': 'translateY(' + thisTop + ')', '-ms-transition': setting.speed / 1000 + 's', '-moz-transition': setting.speed / 1000 + 's', '-webkit-transition': setting.speed / 1000 + 's', '-o-transition': setting.speed / 1000 + 's', 'transition': setting.speed / 1000 + 's' &#125;); &#125; &#125; else &#123; setting.iniAnimate = true; $(this).css(&#123; top: thisTop &#125;); &#125; &#125; &#125;); &#125; //初始化 var init = function($parent) &#123; //初始化 $parent.html(setNumDom(numToArr(setting.num))); runAnimate($parent); &#125;; //重置参数 this.resetData = function(num) &#123; var newArr = numToArr(num); var $dom = $(this).find(\".mt-number-animate-dom\"); if ($dom.length &lt; newArr.length) &#123; $(this).html(setNumDom(numToArr(num))); &#125; else &#123; $dom.each(function(index, el) &#123; $(this).attr(\"data-num\", newArr[index]); &#125;); &#125; runAnimate($(this)); &#125; //init init($(this)); return this; &#125;&#125;)(jQuery);","tags":[]},{"title":"gulp搭建项目流程","date":"2018-03-20T15:27:39.425Z","path":"2018/03/20/gulp搭建项目流程/","text":"所有的环境都是在 node 安装好的基础上执行的。 node -v 查看node的安装情况。npm -v查看npm 的安装情况. gulp自动化构建常用参数 1、src 读取文件或者文件夹 2、dest 生成文件也就是写文件 3、watch 检测文件 4、tesk 指定任务 5、pipe 用流的方式处理 gulp. 解释： bower_components 这个文件下边放的是 通过bower安装的第三方的js等。 build : 项目整合目录，一般在这里整合所有的代码，不压缩。 dist : 项目发布目录，也是压缩所有文件后的。 src : 项目源文件目录，这里放置的都是源文件。 test : 这个是编写自动化测试的 1、在终端进入项目根目录，安装bower. 1bower init 初始化Bower,生成bower.json文件，然后安装需要的的插件以及第三方文件例如angular 执行 1bower install - - save angular 具体查看 bower 的使用方法。 2、安装查看gulp，在项目根目录下。 全局安装gulp 1npm install --global gulp 然后创建配置文件 12npm init 初始化并创建 package.json文件npm install --save-dev gulp 将Node的配置环境装进配置文件中 。 然后安装需要的插件 1npm install xxx —save-dev将文件自动写进配置文件中 一般常用的创建整站的有这些，多个的话可以将插件以空格的形式分开 1npm install gulp-clean gulp-concat gulp-connect gulp-cssmin gulp-imagemin gulp-less gulp-load-plugins gulp-uglify open -—save-dev 然后则是gulpfile.js配置文件的编写。具体为下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//引入gulpvar gulp = require('gulp');//这样的话 其他的模块可以直接使用 $ 符号来引入var $ = require('gulp-load-plugins')();var open = require('open');//定义目录路径var app = &#123; //源代码，文件目录 srcPath: 'src/', //文件整合之后的目录 devPath: 'build/', //项目，发布目录上产部署 prdPath: 'dist/'&#125;;//通过bower安装的插件，需要拷贝到 devPath prdPath中gulp.task('lib',function()&#123; // /**/* 读取这个文件夹下边的所有的文件或者文件夹 gulp.src('bower_components/**/*') //读取完整后进行操作 西安拷贝到整合目录 并重命名，在拷贝到生产目录并重命名 .pipe(gulp.dest(app.devPath + 'vendor')) .pipe(gulp.dest(app.prdPath + 'vendor')) .pipe($.connect.reload()); //文件更改后自动变异 并执行启动服务重新打开浏览器&#125;);//将 html 拷贝到 devPath prdPath中gulp.task('html',function()&#123; gulp.src(app.srcPath + '**/*.html') .pipe(gulp.dest(app.devPath)) .pipe(gulp.dest(app.prdPath)) .pipe($.connect.reload());&#125;);//将 模拟的json 文件 拷贝到 devPath prdPath中gulp.task('json',function()&#123; gulp.src(app.srcPath + 'data/**/*.json') .pipe(gulp.dest(app.devPath + 'data')) .pipe(gulp.dest(app.prdPath + 'data')) .pipe($.connect.reload());&#125;);//将 index.less 文件 拷贝到 devPath prdPath中，index.less引入了所有的其他的lessgulp.task('less',function()&#123; gulp.src(app.srcPath + 'style/index.less') .pipe($.less()) .pipe(gulp.dest(app.devPath + 'css')) .pipe($.cssmin()) .pipe(gulp.dest(app.prdPath + 'css')) .pipe($.connect.reload());&#125;);// 拷贝 js 文件 将所有的源文件中的js 文件整合成index.js 然后拷贝过去gulp.task('script',function()&#123; gulp.src(app.srcPath + 'script/**/*.js') .pipe($.concat('index.js')) .pipe(gulp.dest(app.devPath + 'js')) .pipe($.uglify()) .pipe(gulp.dest(app.prdPath + 'js')) .pipe($.connect.reload());&#125;);//拷贝 压缩 图片 最后放到发布目录下gulp.task('image',function()&#123; gulp.src(app.srcPath + 'image/**/*') //江源图片放到整合目录下，在压缩放到生产目录下 .pipe(gulp.dest(app.devPath + 'image')) .pipe($.imagemin()) .pipe(gulp.dest(app.prdPath + 'image')) .pipe($.connect.reload());&#125;);//总的方法gulp.task('build',['image', 'script', 'less', 'json', 'html', 'lib']);//清除旧文件，每次更新的时候gulp.task('clean',function()&#123; gulp.src([app.devPath,app.prdPath]) .pipe($.clean());&#125;)//编写服务gulp.task('serve',['build'], function() &#123; $.connect.server(&#123; //服务起来的入口 root: [app.devPath], //文件更改后自动刷新页面 livereload: true, //端口号 port: 1234 &#125;); // 在 命令工具中执行 gulp serve 就相当于是启动了服务 //自动打开浏览器 open('http://localhost:1234'); //我们希望更改了文件，就自动编译，并且打包等然后打开浏览器 gulp.watch('bower_components/**/*' , ['lib']); //监听 script 下边的 js 文件，并执行 script 方法 gulp.watch(app.srcPath + 'script/**/*.js', ['script']); gulp.watch(app.srcPath + '**/*.html', ['html']); gulp.watch(app.srcPath + 'data/**/*.json', ['json']); gulp.watch(app.srcPath + 'style/**/*.less', ['less']); gulp.watch(app.srcPath + 'image/**/*', ['image']); //这样文件变更了就会自动构建&#125;);//默认执行的任务，直接 执行 gulp 变行了。都编写完成后再终端 执行 gulp 便可以了。gulp.task('default', ['serve']);","tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"聊一聊package.json","date":"2018-03-20T15:27:08.396Z","path":"2018/03/20/聊一聊package.json/","text":"概述每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境 下面只介绍几个常见的字段，更多字段请移步阮大神文章 scripts字段scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。 下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。 1234567891011121314151617181920212223242526\"scripts\": &#123; \"preinstall\": \"echo here it comes!\", \"postinstall\": \"echo there it goes!\", \"start\": \"node index.js\", \"test\": \"tap test/*.js\"&#125;``` ### dependencies字段，devDependencies字段dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 对应的版本可以加上各种限定，主要有以下几种： &gt; 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 &gt; 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 &gt; 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 &gt; latest：安装最新版本。 有了package.json文件，直接使用npm install命令，就会在当前目录中安装所需要的模块。如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。```bash$ npm install express --save-dev config 字段config字段用于添加命令行的环境变量。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"","date":"2018-03-14T12:23:49.071Z","path":"2018/03/14/回来了/","text":"我回来了，久别的人们","tags":[]},{"title":"面经","date":"2018-03-14T06:51:44.938Z","path":"2018/03/14/面经/","text":"面试总结先来看一篇文章吧 致未来的实习生 自我介绍你好，我叫xxx，就读XX专业，很高兴能得到这次面试的机会。我非常喜欢前端的各种新技术，对前端的现状也有一个比较宏观的了解。目前，我比较擅长使用 XX、XXX。如果公司因业务需求，我愿意去学习相应的前端技术！ 在生活上，我待人真诚 * 有点难度的开发经历值得一说 * 面试：分析问题，再解决问题 * 把面试官往你熟悉的领域引导 面试结束 问技术方面面试官的问题 结合刚刚的面试，可以给我几点技术方面的建议吗 了解一下公司的前端大致在做哪些业务 了解一下公司前端团队的技术栈有哪些 后端主要用什么语言？ 聊的不错的话，可以要一下联系方式 问 HR 的问题 薪水（税前税后月薪多少？一年十三薪？） 是否有补贴？（餐补？电脑补？） 上下班时间 忌问面试结果 HR 面在公司选择上，我比较看重真正重视和尊重员工的公司。人性化 你有什么缺点？ 大型项目经验不足 你有什么优点？ 抗压能力强 你对薪水有什么要求？ 我希望公司能结合我的专业能力和人才市场标准的水平，给我合理的薪水即可 你对加班有什么看法 如果工作需要，加班是没问题的，反正我现在单身，没啥家庭负担。但是我会在日常工作中尽量提高自己的工作效率，减少不必要的加班。 面试的时候 -&gt;_-&gt; 回答问题的方式 要是直接的问题答不出来的话，可以答一些相关的话题 问：你知道http的302是什么吗 答：不好意思，这个我忘记了，不过我知道 200 表示请求成功， 404表示资源没有被找到，4xx代表客户端请求报文错误，5xx代表服务端错误 分点回答 不要冷场，结果并不那么重要，思考过程最重要 HTTP2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务端错误 200 OK：成功 301 Moved Permanently：永久性重定向（请求的资源被分配了新的URL） 302 Found：临时性重定向（请求的资源临时被分配了新的URL） 304 Not Modified：在这种情况下，由于客户端仍然具有以前下载的资源的副本，因此不需要重新传输资源。 400 Bad Request：请求报文中存在语法错误 403 Forbidden：请求被服务器拒绝 性能优化 减少 HTTP 请求次数：浏览器进程一次发送请求的数目是有限的（4、6 不等），如果有很多 HTTP 请求，就会造成请求阻塞，影响体验。 将小图片转 base64 字符串嵌在页面中 合并图片（css 精灵 == CSS Sprites） 合并 CSS 和 JS 文件 采用 lazyLoad（懒加载） 控制资源文件加载优先级（css 放头部、js 放尾部） 使用浏览器缓存 使用 cdn 减少重排 压缩 js、css、图片 DNS优化（即域名收敛）：将静态资源放在一个域名下面，而不要分开放在多个域名下面 资源预加载： 我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到（DNS预解析、资源预获取、预连接、预渲染） CSS 解析选择器是从右向左的，所以应该尽量避免多层嵌套的选择器 http2: 一个二进制协议，头部压缩、多路复用、服务器推送 【前端性能】浅谈域名发散与域名收敛 浅谈网站性能之前端性能优化 前端性能优化 - 资源预加载 js 坑利用循环一次注册多个 setTimeout(()=&gt;{},1000) 后，会在一秒后同时执行这几个计时器，不是一秒执行一个 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 1000)&#125; 从浏览器输入 URL 到页面渲染发生了什么事浏览器先检查请求的内容是否在浏览器缓存中，如果在，则直接解析内容 DNS 解析 URL 浏览器与服务器建立 TCP 连接 客户端发送 HTTP 请求 服务器处理请求，返回 HTTP 响应 关闭 TCP 连接 浏览器解析html生成 DOM tree，解析css生成 CSS Rule Tree DOM 树和 CSS 规则树一起构造出 render 树 将 render 树显示在页面上 同时异步加载网页中 CSS、JavaScript 等外部资源 浏览器的渲染过程 重绘 重排 js async 与 defer http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html 一般情况：解析 html –&gt; 遇到js，暂停解析html –&gt; 下载js –&gt; 执行js –&gt; 继续解析html async：解析html –&gt; 遇到js，异步下载js，但不会暂停解析html –&gt; js下载完毕后，暂停解析html，执行js –&gt; js执行完后，继续解析html defer：解析html –&gt; 遇到js，异步下载js，但不会暂停解析html –&gt; html解析完毕后，开始执行js this 就是你 call 一个函数时，传入的 context https://zhuanlan.zhihu.com/p/23804247 12345func(12) // =&gt; func.call(undefined, 12)obj.func(12) // =&gt; func.call(obj, 12)func.call(context, arg1, arg2, ...) 12345function fn() &#123; console.log(this)&#125;var arr = [fn, fn]arr[0]() // this ==&gt; arr 什么是闭包： 函数 + 函数所在的环境 封装私有变量和私有方法 手动实现 bind 函数 对于实现的过程有什么具体点的要求吗 直接调用 bind 函数并不会直接执行函数 12345678function myBind(context) &#123; var that = this; var args = Array.prototype.slice.call(arguments, 1) return function() &#123; return this.apply(context, args) &#125;;&#125; RESTFUL API：增查删改 GET 用来获取资源 POST 用来新建资源（也可以用于更新资源） PUT 用来更新资源 DELETE 用来删除资源 事件模型： 事件捕获、事件冒泡、事件委托 new 操作符 1. 创建一个新的空对象 obj 2. 将空对象 obj 的 __proto__ 属性设置为构造函数的 prototype 属性 3. 将构造函数内部的 this 设置为 obj 创建自定义类型目前最好的方式：组合使用构造函数模式和原型模式 属性定义在构造函数中，共享的属性和方法定义在原型上 继承的实现 组合继承 原型式继承 寄生式继承 寄生组合式继承（最棒） HTML5 sessionStorage：只存在于当前页面上 跨域 postMessage() jsonp : 本质上是请求回一段js代码，然后在本地执行 CORS web worker 服务器发送事件（SSE) File API Drag and Drop indexedDB vue 相关 数据双向绑定 最核心的方法便是通过 Object.defineProperty() 来实现对属性的劫持，达到监听数据变动的目的（ES6 可以使用） 组件化开发 单文件组件 虚拟 DOM 如果用 js 直接操作 DOM，会造成页面的重排，性能很差 用 js 对象模拟 DOM 树创建出最初的虚拟 DOM，数据发生变化时，生成新的虚拟DOM，与原来的虚拟dom进行比较并将变化应用到最初的虚拟 DOM上，最后再应用到真正的 DOM 上 社区环境好，上手简单 数据驱动，能让你将关注度集中在数据上，而不是繁琐的 DOM 操作上 web 安全相关 SQL 注入 XSS： 跨站脚本（Cross-site scripting） 利用网站开发时留下的漏洞，将恶意脚本注入，在用户访问该网页时执行恶意脚本，从而达到某种恶意的目的（比如向一个有漏洞的评论框里注入 js 代码） 获取用户敏感信息 过滤用户字符串，对敏感字符进行转义 CSRF（或 XSRF）： 跨站请求伪造（Cross-site request forgery） 以用户的名义发起请求，从而达到某种恶意的目的（盗号、发消息、发邮件、转账） 跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 加验证码。 总结 XSS 与 CSRF 两种跨站攻击 跨站请求伪造 永远不要信任从客户端发来的数据。 项目vue-book 中正好把3月份找实习时候看的知识点都用上了，比如 cookie、localstorage、jsonp 等 http的缓存机制 Cache-Control（通过它提供的不同的值来定义缓存策略） Etag（标识符，用作校验，资源发生变化时，他的值也会变化） 浅谈浏览器http的缓存机制 九种浏览器端缓存机制知多少 算法，数据结构冒泡排序 快速排序 二叉树： 先序遍历、中序遍历、后序遍历 nodejs Buffer模块是干什么的： nodejs 用来处理二进制数据的模块，对比与 ES6 的 TypedArray Stream是什么，使用的两种模式： stream 是一种用来表示数据流的抽象概念（文件流、） nodejs stream js 的薄弱点模拟事件 前端安全相关 面试 给出一个实际的需求，看应聘者怎么解决 让应聘者画一个他所在领域的知识概括 比如： CSS 有定位、BFC、文本格式等 本文是好友percymong提供的资源，非常感谢他的指导。","tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"移动端事件介绍","date":"2018-03-14T06:51:44.937Z","path":"2018/03/14/移动端事件介绍/","text":"移动端常用事件介绍 1.手势事件touchstart：当手指放在屏幕上触发; touchmove：当手指在屏幕上滑动时，连续地触发; touchend：当手指从屏幕上离开时触发; touchcancel： 当系统停止跟踪时触发; 该事件暂时使用不到; 2.tap类事件触碰事件，一般用于代替click事件， tap: 手指碰一下屏幕会触发 longTap: 手指长按屏幕会触发 singleTap: 手指碰一下屏幕会触发 doubleTap: 手指双击屏幕会触发 3.swipe类事件swipe：手指在屏幕上滑动时会触发 swipeLeft：手指在屏幕上向左滑动时会触发 swipeRight：手指在屏幕上向右滑动时会触发 swipeUp：手指在屏幕上向上滑动时会触发 swipeDown：手指在屏幕上向下滑动时会触发 事件处理程序的添加与删除1234567891011121314151617181920var EventUtil = &#123; addHandler: function(element,type,handler) &#123; if(element.addEventListener) &#123; element.addEventListener(type,handler,false); &#125;else if(element.attachEvent) &#123; element.attachEvent(\"on\"+type,handler); &#125;else &#123; element[\"on\" +type] = handler; &#125; &#125;, removeHandler: function(element,type,handler)&#123; if(element.removeEventListener) &#123; element.removeEventListener(type,handler,false); &#125;else if(element.detachEvent) &#123; element.detachEvent(\"on\"+type,handler); &#125;else &#123; element[\"on\" +type] = null; &#125; &#125;&#125;; 该函数接受三个参数 element 执行该函数的对象 type 触发事件对象 handler 执行事件 例 ：在window中触摸时触发 打印出事件对象 1234var touch = document.getElementById(\"touch\");EventUtil.addHandler(touch,\"touchstart\",function(event)&#123; console.log(event);&#125;); touches:表示当前跟踪的触摸操作的touch对象的数组。 当一个手指在触屏上时，event.touches.length = 1; 当二个手指在触屏上时，event.touches.length=2, 以此类推 changedTouches:表示上次触摸以来发生了什么改变的touch对象的数组。 每个touch对象都包含了以下几个属性： clientX 触摸目标在视口中的X坐标。 clientY触摸目标在视口中的Y坐标。 Identifier: 标示触摸的唯一ID。 pageX 触摸目标在页面中的X坐标。 pageY 触摸目标在页面中的Y坐标。 screenX触摸目标在屏幕中的X坐标。 screenY 触摸目标在屏幕中的Y坐标。 target 触摸的DOM节点目标。 几个基本知识点1.判断是否为iPhone1234// ：function isAppleMobile() &#123; return (navigator.platform.indexOf(‘iPad‘) != -1);&#125;; 2.自动大写与自动修正 123// 要关闭这两项功能，可以通过autocapitalize 与autocorrect 这两个选项&lt;input type=\"text\" autocapitalize=\"off\" autocorrect=\"off\" /&gt; 3.禁止 iOS 弹出各种操作窗口 -webkit-touch-callout:none 禁止用户选中文字 -webkit-user-select:none 关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格 1this.value = this.value.replace(/\\u2006/g, ‘‘); Andriod 上去掉语音输入按钮 1input::-webkit-input-speech-button &#123;display: none&#125; 判断是否为微信浏览器； 12345678function is_weixn()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==\"micromessenger\") &#123; return true; &#125; else &#123; return false; &#125;&#125;","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"移动端APP 自适应布局","date":"2018-03-14T06:51:44.936Z","path":"2018/03/14/移动端APP 自适应布局/","text":"初涉移动端 ，自适应布局的相关要点如下本文摘自原文链接 1.常规情况下js根据屏幕宽度动态计算 123456789&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0 ,user-scalable=no&quot;&gt;&lt;!-- 视口 宽度=设备的宽度 缩放比例为1 禁止用户缩放--&gt;&lt;script&gt;var deviceWidth = document.documentElement.clientWidth;document.documentElement.style.fontSize = deviceWidth / 7.5 + &apos;px&apos;;//设计稿基于iphone6，宽度为750px，body的width为750px / 100 = 7.5rem//http://520ued.com/tools/rem PX转rem的网站&lt;/script&gt;&lt;style&gt; width=device-width这段代码是让布局视口的尺寸等于理想视口。设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width） 2.媒体查询较密集的断点@media screen and (min-width: 320px) { html {font-size: 14px;} } @media screen and (min-width: 360px) { html {font-size: 16px;} } @media screen and (min-width: 400px) { html {font-size: 18px;} } @media screen and (min-width: 440px) { html {font-size: 20px;} } @media screen and (min-width: 480px) { html {font-size: 22px;} } @media screen and (min-width: 640px) { html {font-size: 28px;} } 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局 flex布局教程","tags":[{"name":"移动端App","slug":"移动端App","permalink":"http://yoursite.com/tags/移动端App/"}]},{"title":"理解移动端click的300ms的延迟响应","date":"2018-03-14T06:51:44.930Z","path":"2018/03/14/理解移动端click的300ms的延迟响应/","text":"本文介绍移动端点击事件的300ms延迟及其解决方法 “Bug”的由来Click事件在移动手机开发中有300ms的延 因为在手机早期，浏览器系统有放大和缩放功能，用户在屏幕上点击两次之后，系统会触发放大或者缩放功能，因此系统做了一个处理，当触摸一次后，在300ms这段时间内有没有触摸第二次，如果触摸了第二次的话，说明是触发放大或缩放功能，否则的话是click事件。因此当click时候，所有用户必须等待于300ms后才会触发click事件。所以当在移动端使用click事件的时候，会感觉到有300ms的迟钝 以下情况不用考虑延迟 桌面浏览器； 如果 viewport meta 标签 中设置了width=device-width，Android 上的 Chrome 32+ 会禁用 300ms 延时； viewport meta 标签如果设置了 user-scalable=no，Android 上的 Chrome（所有版本）都会禁用 300ms 延迟 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; IE10 中，可以使用 css 属性 -ms-touch-action: none 禁止元素双击缩放 解决方案方案1：禁止用户缩放。1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 方案2：使用zepto.js的tap事件。tap事件可以理解为在移动端的click事件，而zepto.js因为几乎完全复制jQuery的api，因此常常被用在h5的开发上用来取代jquery 缺陷：tap事件解决了一个300ms延迟问题，却带来了一个新的重大bug，点击穿透 点击穿透的意思，就是如果一个绝对定位或者固定定位元素处于页面最顶层，对这个元素绑定一个点击事件，那么你点击这个点对应的下面凡是有点击事件或者a标签都会被触发执行. 方案3：fastclick.js首先想办法引入fastclick.js下载fastclick.js点击获取插件源码1&lt;script type='application/javascript' src='/path/to/fastclick.js'&gt;&lt;/script&gt; 如果你使用原生js开发则进行如下声明即可。12345if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false);&#125; 如果你想使用jquery123$(function() &#123; FastClick.attach(document.body);&#125;); 部门内容转自移动端点击事件全攻略，这里的坑你知多少？","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"Js中的事件捕获与冒泡","date":"2018-03-14T06:51:44.926Z","path":"2018/03/14/浅谈Js中的事件捕获与冒泡/","text":"事件捕获与冒泡以及其解决方法 1.事件捕获JS还设置了另外一种处理多（父子）元素多事件触发的方式，叫做事件捕获。事件捕获与事件冒泡完全相反，先触发祖先元素的事件，然后再逐级触发子元素的事件。默认情况下，绑定事件时，采用事件冒泡原则，如果想要进行事件捕获的话，需要设置一个参数 2.事件冒泡事件先出发后代元素，然后逐级‘向上’传递 [ ] 当你使用事件捕获时，父级元素先触发，子级元素后触发 [ ] 当你使用事件冒泡时，子级元素先触发，父级元素后触发 冒泡和捕获事件可以用下图表示（图片来自脚本之家）。 3.addEventListener的基本用法在复杂的项目开发中，javascript和html的解耦变得至关重要，我们被推荐使用事件动态绑定的方式来处理按钮的事件。W3C为我们提供了==addEventListener(==)函数用来为指定的dom元素动态绑定事件这个函数有三个参数： type: 用来设置事件类型，例如click listener: 用来设置监听事件的函数，及type类型的事件发生后执行的函数 useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行可能值:true - 事件句柄在捕获阶段执行false- false- 默认。事件句柄在冒泡阶段执行 4.事件冒泡与事件捕获要是同时进行怎么办在上述绑定事件的代码中，第三个参数不是全部设置的true，就是全部设置成false,那如果既有true，又有false，有的元素设置成按事件冒泡处理，有的元素设置成按事件捕获处理，那怎么办呢？答案是，我们的浏览器更“喜爱”事件捕获：它会先把useCapture为false的元素绑定事件放到一边，按照事件捕获正常的顺序执行useCapture为true的元素绑定事件，最后在按照事件冒泡顺序执行useCapture为false。 5.阻止冒泡、捕获事件的传播是可以阻止的： 在W3c中，使用stopPropagation（）方法 在IE下设置cancelBubble = true； 在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~ 阻止事件的默认行为，例如click 后的跳转~ 在W3c中，使用preventDefault（）方法； 在IE下设置window.event.returnValue = false; ==attachEvent==——兼容：IE7、IE8；不兼容firefox、chrome、IE9、IE10、IE11、safari、opera ==addEventListener==——兼容：firefox、chrome、IE、safari、opera；不兼容IE7、IE8 6.addEventListener的使用方式：1target.addEventListener(type, listener, useCapture); target： 文档节点、document、window 或 XMLHttpRequest。 type： 字符串，事件名称，不含“on”，比如“click”、“mouseover”、“keydown”等。 listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。 useCapture ：是否使用捕捉，一般用 false 。例如： 1document.getElementById(\"testText\").addEventListener(\"keydown\", function (event) &#123; alert(event.keyCode); &#125;, false); 在IE 7、8中使用1target.attachEvent(type, listener); target： 文档节点、document、window 或 XMLHttpRequest。 type： 字符串，事件名称，含“on”，比如“onclick”、“onmouseover”、“onkeydown”等。 listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。 例如：1document.getElementById(\"txt\").attachEvent(\"onclick\",function(event)&#123;alert(event.keyCode);&#125;); W3C 及 IE 同时支持移除指定的事件, 用途是移除设定的事件, 格式分别如下: W3C格式: 1removeEventListener(event,function,capture/bubble); Windows IE的格式如下:1detachEvent(event,function); 阻止冒泡的兼容性写法12345678function stopBubble(event)&#123; var e=arguments.callee.caller.arguments[0]||event; if(e&amp;&amp;e.stopPropagation)&#123; e.stopPropagation() &#125;else if(window.event)&#123; window.event.cancelBubble=true; &#125;&#125; 阻止浏览器默认行为的兼容性写法1234567891011function stopDefault(event)&#123; var e=arguments.callee.caller.arguments[0]||event; //阻止默认浏览器动作(W3C) if(e&amp;&amp;e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; //IE中阻止函数默认动作的方式 window.event.returnValue=false; &#125; return false;&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"浅谈CSS布局","date":"2018-03-14T06:51:44.917Z","path":"2018/03/14/浅谈CSS布局/","text":"1.水平居中水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍三种实现水平居中的方法: 注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素 a.使用inline-block 和 text-align实现12.parent&#123;text-align: center;&#125;.child&#123;display: inline-block;&#125; 优点：兼容性好；不足：需要同时设置子元素和父元素 b.使用margin:0 auto来实现1.child&#123;width:200px;margin:0 auto;&#125; 缺点: 需要指定宽度 c.使用绝对定位实现12.parent&#123;position:relative;&#125;.child&#123;position:absolute;left:50%;transform:translate(-50%);&#125; /或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好/ 2.两列定宽，一列自适应 基本html结构为父容器为parent,自容器为left,center,right.其中，left,center定宽，right自适应 a.利用float+margin实现12.left,.center&#123;float:left:width:200px;&#125;.right&#123;margin-left:400px;&#125; b.利用float+overflow实现12.left,.center&#123;float:left:width:200px;&#125;.right&#123;overflow:hidden;&#125; 3.两侧定宽，中栏自适应 a.利用float+margin实现123.left&#123;width：100px;float:left;&#125;.center&#123;float:left;width:100%;margin-right:-200px;&#125;.right&#123;width:100px;float:right;&#125; b.利用table实现1234.parent&#123;width:100%;display:table;table-layout:fixed&#125;.left,.center,.right&#123;display:table-cell;&#125;.left&#123;width:100px;&#125;.right&#123;width:100px;&#125; 链接来源：慕课网 4.inline和block 的区别 常见的块级元素 有 div, form, table, p, h1-h6, dl, ol, ul 等。 常见的内联元素 有 span, a, strong, em, lable, input, select, textarea, img, br 等。 display:block1.block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。2.block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。3.block元素可以设置margin和padding属性。 display:inline1.inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。2.inline元素设置width,height属性无效。3.inline元素的margin和padding属性，水平方向的会产生边距效果；但竖直方向无效果 display:inline-block将对象呈现为inline对象的内容作为block对象呈现。 5.postion 值 描述 absolute 生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位 脱离文档流 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位 脱离文档流 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 inherit 规定应该从父元素继承 position 属性的值。 6.float 1.元素浮动后脱离了文档流，所以父元素是无法根据元素来自适应的。关于float产生的影响以及解决方法，请查看此文档 2.浮动元素会被自动设置成块级元素，相当于给元素设置了display:block 3.多个浮动方向一致的元素使用流式排列","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"文本框输入效果总结","date":"2018-03-14T06:51:44.911Z","path":"2018/03/14/文本框输入效果/","text":"文本框输入效果 简单的罗列了几个文本框输入后的效果;话不多说，直接上代码： 1、选中去除文本框文字，离开后显示原有文字： 1&lt;input name=\"key\" type=\"text\" id=\"key\" value=\"关键词\" size=\"30\" onmouseover=this.focus();this.select(); onclick=\"if(value==defaultValue)&#123;value='';this.style.color='#000'&#125;\" onBlur=\"if(!value)&#123;value=defaultValue;this.style.color='#999'&#125;\" style=\"color:#999\" /&gt; 2、选中后方可编辑： 12&lt;input type=\"checkbox\" name=\"tpbox\" value=\"1\" id=\"hydb1\"&gt;选中这边编辑&lt;input type=\"text\" name=\"txtNo\" size=\"30\" value=\"选中前面的选项方可编辑\" edit()&gt; 123456789&lt;script&gt;function edit(val) &#123; if (val) &#123; C.disabled = false; &#125; else &#123; document.getElementById(&quot;hydb1&quot;).disabled = true; &#125;&#125;&lt;/script&gt; 3、点击链接后方可编辑： 12&lt;a href=\"#\" onclick=\"username.readOnly=false;alert('你好，欢迎使用！')\"&gt;先点击我哦！&lt;/a&gt; 你的姓名：&lt;input id=\"username\" value=\"--请输入--\" size=\"30\" readOnly&gt; &lt;/br&gt; 4、输入框从中间输入：从中间输入： 1&lt;input type=\"text \" name=\"mid \" style=\"text-align:center; \"&gt; &lt;/br&gt; 6、输入框只能输入数字（用的是正则表达式）：你 的年龄： 1&lt;input onkeyup=\"value=value.replace(/[^\\d]/g, '') \" onbeforepaste=\"clipboardData.setData( 'text',clipboardData.getData( 'text').replace(/[^\\d]/g, '')) \"&gt; 7、输入框只能输入中文（用的是正则表达式）：你的中文名： 1&lt;input onkeyup=\"value=value.replace(/[ -~]/g, '') \" onkeydown=\"if(event.keyCode==13)event.keyCode=9 \"&gt; &lt; 8、只能输入英文和数字（用的是正则表达式）： 你 的昵称： 1&lt;input onkeyup=\"value=value.replace(/[\\W]/g, '') \" onbeforepaste=\"clipboardData.setData( 'text',clipboardData.getData( 'text').replace(/[^\\d]/g, '')) \" onkeydown=\"if(event.keyCode==13)event.keyCode=9 \"&gt; 9、输入框不能编辑，但表单可以获得输入框内的值： 1234&lt;input type=\"text \" value=\"afreon \" onclick=\"alert( '总和不能编辑！'); \" onfocus=\"this.blur() \" /&gt; &lt;/br&gt;&lt;input type=\"text \" value=\"afreon \" onclick=\"alert(this.value); \" readonly /&gt; &lt;/br&gt;&lt;input value=\"不可修改 \" readonly=\"true \" type=\"text \"/&gt;//:字体颜色为黑体 10、输入框不能编辑，并且表单不能获得输入框内的值12&lt;input value=\"不可修改 \" disabled=\"disabled \" type=\"text \" /&gt;//:字体颜色为灰体 &lt;/br&gt;11、输入框禁止输入法： &lt;/br&gt;&lt;input onpaste=\"return false \" style=\"ime-mode:disabled \"&gt; 以上代码部门引用这位大哥的博客 持续更新…..","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"visual studio code 编辑器","date":"2018-03-14T06:51:44.896Z","path":"2018/03/14/工欲善其事，必先利其器/","text":"工欲善其事，必先利其器安装visual studio code 选择一款合适自己的编辑器尤为重要，目前比较主流的编辑器 有sublime-textatom 等，本文简单介绍VSC的安装及使用！ 在visual studio code官网中点击下载合适自己电脑的版本！然后一路next安装！ 安装完成后点击打开窗口，安装新的插件。按照插件安装经验打开新的扩展窗口，选择自己需要的插件安装 介绍几个比较实用的插件1.HTML Snippets超级实用且初级的 H5代码片段以及提示 2.HTML CSS Support让 html 标签上写class 智能提示当前项目所支持的样式 3.Path Intellisense自动路劲补全，个人认为这个非常有用 4.Atuo Rename Tag 修改 html 标签，自动帮你完成尾部闭合标签的同步修改，和 webstorm 一样 常用快捷键1.格式调整 代码行缩进 Ctrl+[ 、 Ctrl+] Ctrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容 代码格式化： Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 2.光标相关 移动到行首： Home 移动到行尾： End 移动到文件结尾： Ctrl+End 移动到文件开头： Ctrl+Home 移动到后半个括号： Ctrl+Shift+] 选择从光标到行尾： Shift+End 选择从行首到光标处： Shift+Home 删除光标右侧的所有字： Ctrl+Delete 扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right 多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up 同时选中所有匹配： Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (在 sublime * 中是删除当前行，后面自定义快键键中，设置与 Ctrl+Shift+K 互换了) 3.查找替换 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 好的，今天就写这么多，祝愿世界和平！","tags":[{"name":"vsc","slug":"vsc","permalink":"http://yoursite.com/tags/vsc/"}]},{"title":"工作杂记","date":"2018-03-14T06:51:44.859Z","path":"2018/03/14/工作杂记（一）/","text":"记录工作中的一些小知识点之类的杂谈 安装cnpm先安装好node 然后命令行执行 node -v如下，表示安装成功然后安装cnpm 需要详细了解cnpm的朋友请前往官网https://npm.taobao.org/ 查看在cmd中输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 即可将npm指向国内镜像源，之后输入cnpm -v 直接将npm的仓库修改为淘宝镜像 方法如下 npm是一个很好用的工具，全场是Node Packet Manager，是一个nodejs的包管理工具，但是美中不足的是当我们去安转包的时候却发现下载的速度太慢，但是没关系，还是有方法的就是利用淘宝的国内镜像，一下是3个设置的方法：镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）: 1.通过config命令 1npm config set registry https://registry.npm.taobao.org npm info underscore （如果上面配置正确这个命令会有字符串response）2.命令行指定 1npm --registry https://registry.npm.taobao.org info underscore 3.编辑 ~/.npmrc 加入下面内容 registry = https://registry.npm.taobao.org 网页中咨询客服随机跳转代码 12345678910Btn.onclick = getServiceQQ(); // 调用 function rd(n, m) &#123; // 生成随机数 var c = m - n + 1; return Math.floor(Math.random() * c + n); &#125; function getServiceQQ() &#123; // 随机跳转到qq var qqary = new Array(\"2851282570\", \"2851282668\", \"2851282678\", \"2851282590\", \"2851282686\", \"2851282632\", \"2851282683\", \"2851282657\"); window.open(\"http://wpa.qq.com/msgrd?v=3&amp;uin=\" + qqary[rd(0, 7)] + \"&amp;site=qq&amp;menu=yes\");&#125; less编译工具 考拉十分强大的编译工具 下载链接博客园-Less/Sass编译工具，koala使用指南 验证输入值不能包含特殊字符代码：12345var reg = /^[.0-9a-zA-Z\\u4e00-\\u9fa5]+$|^[0-9a-zA-Z][0-9a-zA-Z ]+[0-9a-zA-Z]$/i; if (!reg.test(value)) &#123; alert(\"关键词不可包含特殊字符和空格！\"); return; &#125;","tags":[{"name":"小知识","slug":"小知识","permalink":"http://yoursite.com/tags/小知识/"}]},{"title":"文字超出显示","date":"2018-03-14T06:51:44.858Z","path":"2018/03/14/多行文字超出显示.../","text":"适用于移动端的文字超出布局 单行文字超出：12345678&lt;style&gt;.txt&#123; overflow: hidden; text-overflow:ellipsis; white-space: nowrap;&#125;&lt;/style&gt; 多行文字超出显示：123456789&lt;style&gt;.txt&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3;overflow: hidden;&#125;&lt;/style&gt; 点击查看相关链接","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"同源策略和JSONP","date":"2018-03-14T06:51:44.842Z","path":"2018/03/14/同源策略和JSONP/","text":"解决Ajax无法跨域请求的问题先补充两个概念： 同源策略处于安全考虑，浏览器约定俗成执行这一规定： 协议相同 端口相同 域名相同 阮一峰-浏览器同源政策及其规避方法 跨域请求的概念 JSON JSON的优点： 1、基于纯文本，跨平台传递极其简单； 2、Javascript原生支持，后台语言几乎全部支持； 3、轻量级数据格式，占用字符数量极少，特别适合互联网传递； 4、可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的； 5、容易编写和解析，当然前提是你要知道数据结构； JSONP的诞生 首先，因为ajax无法跨域，然后开发者就有所思考 其次，开发者发现，script标签的src属性是可以跨域的把跨域服务器写成 调用本地的函数 ，回调数据回来不就好了？ json刚好被js支持（object）调用跨域服务器上动态生成的js格式文件（不管是什么类型的地址，最终生成的返回值都是一段js代码） 这种获取远程数据的方式看起来非常像ajax，但其实并不一样 便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP。 传递一个callback参数给跨域服务端，然后跨域服务端返回数据时会将这个callback参数作为函数名来包裹住json数据即可。 简言之： json不支持跨域，而js可以跨域，因此在服务器端用客户端提供的js函数名将json数据封装起来，再将函数提供给客户端调用，从而获得json数据。 参考资料","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"前端性能优化","date":"2018-03-14T06:51:44.836Z","path":"2018/03/14/前端性能优化/","text":"记录前端性能优化的相关知识","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"前端开发的几款插件","date":"2018-03-14T06:51:44.835Z","path":"2018/03/14/前端开发的几款浏览器插件/","text":"介绍一些开发常用的利器”插件” 持续更新中 json-viewer最近在请求json 数据的时候，返回的一大堆数据，没有任何排版，看起来很不爽，网上找了个格式化的插件，json-viewer看起来爽多了。 如下图： 网址二维码： 有时候需要在移动端查看一些网址手动输入网址巨慢，这时候，就需要一个快捷方式啦，扫面二维码啊，下载插件二维码(QR码)生成器(QR Code Generator)就可以轻松搞定了。 翻墙 Proxy SwitchyOmega经常需要翻墙的我们，一直渴望一款持久好用的翻墙软件，现在就介绍一款自己用的 firefly.点击进入github下载如下图，点击下载对应的版本安装即可 代理管理插件 Proxy SwitchyOmega顺便介绍介绍一款方便快捷的代理管理插件Proxy SwitchyOmega在安装好刚刚的firefly之后 点击运行可以看到他的端口号为 在Proxy SwitchyOmega中添加对应的情景模式，就可以使用了如图 持续更新中….","tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}]},{"title":"浏览器兼容性总结","date":"2018-03-14T06:51:44.814Z","path":"2018/03/14/兼容性总结/","text":"介绍前端常见的几个兼容性问题1.inputinput 设置左右padding之后，ie中输入过多内容后，padding消失。解决方法：在外面套一层div设置宽高，padding然后设置input的宽高为100% 2.在设置float的div在IE下设置margin时会产生双边距，这是IE6的一个典型bug，解决方法是加上display:inline; 3.Ie6下定义1px高的divie6默认div高度为一个字体显示的高度，所在ie6下div的高度大于等于一个字的高度，因此在ie6下定义高度为1px的容器，显示的是一个字体的高度 overflow:hidden; || zoom:0.08; || line-height:1px; 4.chrome浏览器 中文界面下默认会将小于12px 的文本强制按照12px 显示,可通过加入 CSS 属性-webkit-text-size-adjust: none;解决. 5.各个浏览器默认的内外边距不同解决 ：*{margin:0;padding:0;} IE6 width为奇数，右边多出1px的问题问题：父级元素采用相对定位，且宽度设置为奇数时，子元素采用绝对定位，在ie6中会出现右侧多出1像素解决：将宽度的奇数值改成偶数 7.IE6两个层之间3px的问题问题：左边层采用浮动，右边没有采用浮动时在ie6中两层之间就会产生3像素的间距解决：A、右边层也采用浮动 floatB、左边层添加属性 margin-right:-3px; 除去滚动条的问题问题：隐藏滚动条解决：1、只有ie6-7支持2、除ie6-7不支持 body{overflow:hidden}3、所有浏览器 html{overflow:hidden} 9、标准的事件绑定方法函数为addEventListener，但IE下是attachEvent； 10.封装一个获取行外样式的函数:(兼容所有浏览器,包括低版本IE6,7) 12345678910funtion getStyle(obj,name)&#123; if(obj.currentStyle)&#123; //IE return obj.currentStyle[name]; &#125;else&#123; //Chrom,FF return getComputedStyle(obj,false)[name]; &#125;&#125; 调用：getStyle(oDiv,'width');","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"为啥行内元素还能设置宽高呢？","date":"2018-03-14T06:51:44.812Z","path":"2018/03/14/为啥行内元素还能设置宽高呢？/","text":"HTML中的行内元素 ，块状元素以及置换元素最近碰到一个很神奇的问题：1.img标签是块状元素吗？当然不是，他不会单独占据一行那为何能够设置宽高呢？这就把我难住了，后来插了一下资料发现了个‘大秘密’先来说说HTMl标签的极大特性 块状元素最明显的特征就是独自占领一行，自动充满父级元素的内容区域，绝不会让别人“侵略”（当然可以通过其他方式去改变他）。常见的有：div，p..等等。通过CSS设定了浮动（float属性，可向左浮动或向右浮动）以及设定显示（display）属性为“block”或“list-item”的元素都是块级元素。 行内元素：上面说块及元素独自占领一行，行内元素就没这么霸道了，他可以左右都允许有元素，最常见的就是通过display:’inline’设置以后都会变成行内元素。 行内非替换元素：对行内非替换元素如a元素、span元素等，设置宽度width 无效。设置高度height无效，可以通过line-height来设置。设置margin只有左右margin有效，上下无效。（这就是span的margin-top无效的原因）设置padding只有左右padding有效，上下则无效。块级元素的width/height/margin/padding都是有效的 替换元素浏览器根据其标签的元素与属性来判断显示具体的内容。比如： type=”text” 的是，这是一个文本输入框，换一个其他的时候，浏览器显示就不一样 (X)HTML中的、、、、都是替换元素，这些元素都没有实际的内容。","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"一种书写很简单的javascipt继承方式","date":"2018-03-14T06:51:44.779Z","path":"2018/03/14/一种书写很简单的javascipt继承方式/","text":"一、一种书写起来很简单的继承方式js的继承一直是一个很烦人的概念，之前整理过一次 但是还是没有弄清楚。最近发现一种比较简单的书写方式，拿出来分享一下。 简单的理解为：什么是继承： 在原有对象上稍加修改，得到另一个新对象，原有对象不会受到影响 复用代码的一种形式；子类不影响父类 继承一些父类的功能 二、下面这个实例演示继承的一种方法12345678910111213141516171819202122232425262728293031323334 &lt;script&gt; function person(id, name, age) &#123; this.id = document.getElementById(id); this.name = name; this.age = age; &#125; person.prototype.sayhello = function () &#123; console.log(\"你好，我是\" + this.name + \" 我今年\" + this.age + \"岁了\") &#125; var student1 = new person(\"box\", \"gcf\", 22) student1.sayhello(); //输出 你好 我是郭春福 今年22了 // 继承核心 function extend(son, parent) &#123; for (arr in parent) &#123; son[arr] = parent[arr] &#125; &#125; function man(id, name, age) &#123; person.call(this, id, name, age) &#125; extend(man.prototype, person.prototype); var student2 = new man(\"box2\", \"zjn\", 23) student2.sayhello() //输出 你好我是zjn 今年23岁了 继承了父类person 的属性和方法 man.prototype.show = function () &#123; alert(\"大家好，我是\" + this.name); &#125; student2.show() //弹出 大家好 我是zjn &lt;/script&gt; 就是这样，希望对大家有所帮助","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"vue项目中的跨域请求，axios&jsonp","date":"2018-03-14T06:51:44.775Z","path":"2018/03/14/vue项目中的跨域请求，axios&jsonp/","text":"记录vue项目中的跨域请求方法 天天画页面，写一些html css感觉自己就是一个无脑机器人，文章记录一下vue 中跨域请求 我们都知道由于同源策略，ajax无法进行跨域请求，在vue项目中，使用axios进行ajax请求。 使用axios先奉上axios中文文档；具体操作按照教程来 1.构建项目，安装axios 1$ npm install axios 新建一个ajax.js文件，用来对ajax作一定的封装点击下载 ajax.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import axios from 'axios'import querystring from 'querystring'const base = ''axios.defaults.withCredentials = trueaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'axios.defaults.headers.referer = 'https://cnodejs.org/'axios.defaults.headers.host = 'cnodejs.org'// 下面的方法就能发送请求// var ajax = &#123;// get: function(path, params)&#123;// var config = `$&#123;base&#125;` + path + '?' + querystring.stringify(params)// return axios.get(config).then(res =&gt; res.data)// &#125;,// post: function(path, params)&#123;// return axios.post(`$&#123;base&#125;` + path, params).then(res =&gt; res.data)// &#125;// &#125;// 以下是对发送的参数作了过滤空字符串的操作var ajax = &#123; get: function(path, params) &#123; var config if (params === void 0) &#123; config = `$&#123;base&#125;` + path &#125; else &#123; params = trimObject(params) config = `$&#123;base&#125;` + path + '?' + querystring.stringify(params) &#125; return axios.get(config).then(res =&gt; res.data) &#125;, post: function(path, params) &#123; if (params === void 0) &#123; params = &#123;&#125; &#125; params = trimObject(params) axios.post(`$&#123;base&#125;` + path, params).then(res =&gt; res.data) &#125;&#125;// 添加请求拦截器axios.interceptors.request.use(function(config) &#123; // 在发送请求之前做些什么 return config&#125;, function(error) &#123; // 对请求错误做些什么 return Promise.reject(error)&#125;)// 添加响应拦截器axios.interceptors.response.use(function(response) &#123; // 对响应数据做点什么 return response&#125;, function(error) &#123; // 对响应错误做点什么 return Promise.reject(error)&#125;)function trimObject(data) &#123; var obj = data for (var k in obj) &#123; if (Object.prototype.toString.call(obj[k]).slice(8, -1) === 'String') &#123; obj[k] = obj[k].trim() &#125; else if (Object.prototype.toString.call(obj[k]).slice(8, -1) === 'Object') &#123; trimObject(obj[k]) &#125; &#125; return obj&#125;export default ajax 配置config中的index.js如下图： 执行git请求时候，最终路径为 1`$&#123;base&#125;` + path + &apos;?&apos; + querystring.stringify(params) 其中base是api中的基础链接 ，比如所有用户相关的api，中间可能会出现 /user/login…/user/info…等等，这个user就是其中的base，当然，具体还是要视情况而定。 在页面中发送请求如下图 请求成功 使用jsonp 安装jsonp 1cnpm install jsonp --save 新建一个jsonp.js文件，封装一个jsonp 1234567891011121314151617181920212223import originJsonp from 'jsonp'export default function jsonp(url, data, option) &#123; url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) return new Promise((resolve, reject) =&gt; &#123; originJsonp(url, option, (err, data) =&gt; &#123; if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;export function param(data) &#123; let url = '' for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += '&amp;' + k + '=' + encodeURIComponent(value) &#125; return url ? url.substring(1) : ''&#125; 在页面中调用：","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Vue学习（二）-----vue-router","date":"2018-03-14T06:51:44.763Z","path":"2018/03/14/vue学习（二）-----vue-router2.0（基础部分）/","text":"使用vue-router构建SPA小插曲在使用路由时发现，默认的链接中会出现/#/看起来很不舒服，后来查了一下发现，只需要将router换个模式就行了如下： 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 官网如是说：vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 命名路由给每一个路由”起一个名字” 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ]&#125;)// 在渲染时 &lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt; // 或者router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 嵌套路由 在VueRouter 的参数中使用 children 配置：父组件的 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 。 要注意，以 / 开头的嵌套路径会被当作根路径。这让你充分的使用嵌套组件而无须设置嵌套的路径。在使用器那套路由时候。子组件路由前面不要加 ‘/‘ 12345678const User = &#123; template: ` &lt;div class=\"user\"&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125; 编程式导航router.push()router.push(location, onComplete?, onAbort?)在vue实例中，可以采用router.push()访问路由实例 1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) router.go(n)这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。 123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 命名视图有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar（侧导航） 和 main（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default注意：在使用命名视图的时候，注routes中的component要换成==components==12345678910111213141516&lt;router-view &gt;&lt;/router-view&gt;&lt;router-view name=\"router1\"&gt;&lt;/router-view&gt;&lt;router-view name=\"router2\"&gt;&lt;/router-view&gt;const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: 默认的组件名称, router1: 路由1的组件名称, router2: 路由2的组件名称 &#125; &#125; ]&#125;) 重定向和别名 重定向』的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b，那么『别名』又是什么呢？ /a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。 实例 参考资料：vue-router2官方文档","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Vue学习（一）-----组件","date":"2018-03-14T06:51:44.747Z","path":"2018/03/14/vue学习（一） 组件之间传参数/","text":"组件的注册以及父子组件之间传递参数接触vue实践不短了，却总是磕磕碰碰，没有一个系统的概念，现在写几篇文章，记录一下学习的心得。 组件的注册：下面是vue 官网提供的注册案例 ： 全局注册：1234567891011&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 局部注册：var Child = { template: '&lt;div&gt;A custom component!&lt;/div&gt;' } new Vue({ // ... components: { // &lt;my-component&gt; 将只在父组件模板中可用 'my-component': Child } }) 全局组件在实际开发的过程中，使用vue-cli脚手架搭建项目之后,可以按照下面的方式注册： 全局通用的组件，可以在components文件夹下面建立一个public文件夹，专门放置通用的组件。 在public文件夹下的index.js 注册组件如下图所示，这样做的目的是方便维护，当然也可以直接在main.js中将组件一个一个 import进去，然后在再用。 局部组件直接在需要的页面中把组件import进来，然后注册，即可使用 组件之间传递参数父对子传递子组件通过props”告诉”父组件自己需要什么参数，父组件便给他传递什么参数 子对父传递子对父传递需要利用事件传递参数，下图是自己YY出来的逻辑 dome如下：子组件执行某方法，将参数通过自定义事件传递给父组件 父组件执行该自定义事件时调用某方法将子组件传递的参数获取到 参考资料：Vue 爬坑之路（二）—— 组件之间的数据传递vue中各组件之间传递数据的方法示例 关于子对子组件之间的传参，以及slot内容分发，之后的博文中再做讲解。","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue学习（前置）------代码规范","date":"2018-03-14T06:51:44.741Z","path":"2018/03/14/vue学习(前置) ----------代码规范/","text":"写不了一手漂亮的代码的程序猿不是好画家、其实这是在接触Vue时候就开始看的了，不过现在发现也不晚，遵守一定约定俗成的规范，让自己的代码更通俗易懂。传送门：vue官方代码风格Vue.js 组件编码规范-小丸子的博客 个人遵守的规范： 组件文件名称(kebab-case) my-component.vue 注册组件时组件名称（PascalCase） myComponent html文件中使用组件 (kebab-case) props 值加类型验证 props:{‘msg’:String} 组件命名为多个单词 指令缩写 模板中使用简单表达式，使用计算属性 v-for设置键值 组件命名为多个单词这样的目的是可以防止未来跟HTML元素冲突Bad12345678Vue.component('todo', &#123; // ...&#125;)export default &#123; name: 'Todo', // ...&#125; Good123456789101112131415161718192021Vue.component('todo-item', &#123; // ...&#125;)export default &#123; name: 'TodoItem', // ...&#125;``` ### data必须是函数当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。```js// In a .vue fileexport default &#123; data () &#123; return &#123; foo: 'bar' &#125; &#125;&#125; Prop验证类型 它们写明了组件的 API，所以很容易看懂组件的用法； 在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。 Bad1props: ['status'] Good123props: &#123; status: String&#125; v-for 设置键值Bad12345&lt;ul&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; Good12345678 &lt;ul&gt; &lt;li v-for=\"todo in todos\" :key=\"todo.id\" &gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 组件名称大小写单文件组件名称大小写个人默认使用，组件名使用(kebab-case)规则Bad12components/|- mycomponent.vue Good12 components/|- my-component.vue 模板中组件名大小写个人默认使用，组件名使用(kebab-case)规则 js中组件名称123456export default &#123; name: 'MyComponent', // ...&#125;import MyComponent from './my-component.vue' 不在模板中使用复杂的表达式在需要复杂的表达式时候，使用计算属性Bad 12345&#123;&#123; fullName.split(' ').map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(' ')&#125;&#125; Good 12345678910&lt;!-- 在模板中 --&gt;&#123;&#123; normalizedFullName &#125;&#125;computed: &#123; normalizedFullName: function () &#123; return this.fullName.split(' ').map(function (word) &#123; return word[0].toUpperCase() + word.slice(1) &#125;).join(' ') &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue中引入资源","date":"2018-03-14T06:51:44.724Z","path":"2018/03/14/vue中引入资源/","text":"写是为了不写 引入jQuery 安装 1cnpm install jquery --save 在webpack.base.conf.js里加入 1234567891011var webpack = require(\"webpack\")&lt;!--在module.exports的最后加入--&gt;plugins: [new webpack.optimize.CommonsChunkPlugin('common.js'),new webpack.ProvidePlugin(&#123;jQuery: \"jquery\",$: \"jquery\"&#125;)] 在main.js 引入就ok了 1import $ from 'jquery' 将npm的仓库改为淘宝镜像这样就可以直接使用npm install安装 速度跟cnpm install一样了 1npm install --registry=https://registry.npm.taobao.org 引用less1npm install less-loader --save-de 在单文件中使用内联样式123&lt;style lang=\"sass\" scoped&gt; //sass样式 &lt;/style&gt;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Vue中事件处理器","date":"2018-03-14T06:51:44.705Z","path":"2018/03/14/Vue中事件处理器/","text":"监听事件vue 使用 v-on监听DOM事件来触发js代码1&lt;button v-on:click=\"count+1\"&gt;增加1&lt;/button&gt; 方法事件处理器123456789//html&lt;button v-on:click=\"sayhello\"&gt;调用函数&lt;/button&gt;//vuemethods:&#123; sayhello:function()&#123; alert(\"hello world!\") &#125;&#125; 这里调用的函数也可以传参数 事件修饰符123456789101112&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; 12&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; Vue 允许为 v-on 在监听键盘事件时添加关键修饰符：全部的按键别名： .enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right 可以通过全局 config.keyCodes 对象自定义键值修饰符别名 点击enter的时候提交1&lt;input @keyup.enter=&quot;submit&quot;&gt; 点击和键盘事件实例 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- &lt;div class=\"box\" :class=\"&#123;active:isactive&#125;\"&gt;&lt;/div&gt; &lt;button @click=\"changecolor\"&gt;点击变色&lt;/button&gt; --&gt; &lt;!-- 输入完成后点击enter 键提交 --&gt; &lt;p&gt;输入点击添加 或者键盘点击enter 事件确定&lt;/p&gt; &lt;button @click=\"show\"&gt;添加&lt;/button&gt; &lt;input type=\"text\" @keyup.enter=\"show\" v-model=\"message\"&gt; &lt;ol&gt; &lt;li v-for=\"(item,index) in showmessage\"&gt; &lt;span&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;button @click=\"deleate(index)\"&gt;删除&lt;/button&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script&gt; var app1 = new Vue(&#123; el: \"#app\", data: &#123; // isactive: false, showmessage: [ ], message: '' &#125;, methods: &#123; // changecolor: function () &#123; // this.isactive = true // &#125;, show: function () &#123; this.showmessage.push(this.message) this.showmessage.reverse() &#125;, deleate: function (index) &#123; this.showmessage.splice(index, 1) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue中class与style的绑定","date":"2018-03-14T06:51:44.696Z","path":"2018/03/14/Vue中class与style的绑定/","text":"为了减少书写量 以下实例代码中直接书写vue中的data 对象 绑定class对象语法12345678&lt;div class=\"box\" v-bind:class=\"&#123;active:isactive,box:isbox&#125;\"&gt;&lt;/div&gt;//vuedata&#123; isactive:true, isbox:false,&#125; 当isactive 为true 时候 会为该div添加一个名为 active 的类 也可以直接绑定数据里的一个对象12345678&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;//vue的data 对象内容为data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 数组语法123456&lt;div class=\"box\" v-bind:class=\"[activeClass,errorClass]\"//vuedata&#123; activeClass: 'active', errorClass: 'error',&#125; 以上div的class会渲染为 box active error三个 当有多个条件 class 时这样写有些繁琐。可以在数组语法中使用对象语法1&lt;div class=\"Box\" v-bind:class=\"[activeClass,&#123;box:isbox&#125;]\" id=\"app3\"&gt;&lt;/div&gt; 当你在一个定制的组件上用到 class 属性的时候，这些类将被添加到根元素上面，这个元素上==已经存在的类不会被覆盖== 绑定内联样式对象语法 直接将属性写在行内 1&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; 绑定到一个样式对象上 12345678&lt;div class=\"box\" v-bind:style=\"styleObject\"&gt;//vuedata&#123; styleObject:&#123; background:'red', width:'100px' &#125;&#125; 数组语法v-bind:style 的数组语法可以将多个样式对象应用到一个元素上1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt; 自动添加前缀当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"TCP协议与UDP协议的区别","date":"2018-03-14T06:51:44.694Z","path":"2018/03/14/TCP 和UDP的区别/","text":"文章转自博客园-TCP协议与UDP协议的区别 TCP协议与UDP协议的区别 TCP/IP协议是一个协议簇。里面包括很多协议的。UDP只是其中的一个。之所以命名为TCP/IP协议，因为TCP,IP协议是两个很重要的协议，就用他两命名了。TCP/IP协议集包括应用层,传输层，网络层，网络访问层 其中应用层包括: 超文本传输协议(HTTP):万维网的基本协议. 文件传输(TFTP简单文件传输协议): 远程登录(Telnet),提供远程访问其它主机功能,它允许用户登录 internet主机,并在这台主机上执行命令. 网络管理(SNMP简单网络管理协议),该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等. 域名系统(DNS),该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. 其次网络层包括: Internet协议(IP) Internet控制信息协议(ICMP) 地址解析协议(ARP) 反向地址解析协议(RARP)-网络访问层:网络访问层又称作主机到网络层(host-to-network).网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接. 当然我这里说得不够完善，TCP/IP协议本来就是一门学问，每一个分支都是一个很复杂的流程，但我相信每位学习软件开发的同学都有必要去仔细了解一番 TCP协议和UDP协议的区别。TCP （==Transmission Control Protocol==）传输控制协议是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程 主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 TCP三次握手过程 1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我. 2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我 3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:”我已收到回复,我现在要开始传输实际数据了这样3次握手就完成了,主机A和主机B 就可以传输数据了.3次握手的特点没有应用层的数据SYN这个标志位只有在TCP建产连接时才会被置1握手完成后SYN标志位被置0 TCP建立连接要进行3次握手,而断开连接要进行4次 1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求 2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1 3 由B 端再提出反方向的关闭请求,将FIN置1 4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束. 由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础 UDP（==User Data Protocol，用户数据报协议==） （1） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 （2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。 （3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。 （4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制 （5）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。 （6）UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。UDP的包头结构：源端口 16位目的端口 16位长度 16位校验和 16位 小结TCP与UDP的区别： 1.基于连接与无连接 2.对系统资源的要求（TCP较多，UDP少）； 3.UDP程序结构较简单； 4.流模式与数据报模式 ； 5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"querystring模块介绍","date":"2018-03-14T06:51:44.693Z","path":"2018/03/14/querystring模块介绍/","text":"介绍node.js 中的querystringNode.js v9.2.0 Documentation—Query String 此类一共包括4个方法: querystring这个模块相对的还是比较简单，仅有4个方法。 querystring.stringify 序列化; querystring.parse 反序列化; querystring.escape 编码; querystring.unescape 解码; [内参数]表示可选参数, [sep]指分隔符 默认&amp; , [eq]指分配符 默认= 下面一个一个来介绍: querystring.stringify(obj,[sep],[eq])对象格式化成参数字符串 ,obj就是要格式化的对象,必选参数. 12345678910var obj=&#123;name:\"虾莫\",url:\"http://yijiebuyi.com\"&#125;;var param= querystring.stringify(obj);// 没有指定分隔符和分配符,并且自动编码汉字console.log(param);// 输出： name=%E8%99%BE%E8%8E%AB&amp;url=http%3A%2F%2Fpinkboy.top querystring.parse(str, [sep], [eq], [options])参数字符串格式化成对象 1234567891011121314151617var obj = &#123; name: \"虾莫\", url: \"http://pinkboy.top\"&#125;var param = querystring.stringify(obj)console.log(param)var newobj = querystring.parse(param)console.log(typeof (newobj), newobj)// 输出name=%E8%99%BE%E8%8E%AB&amp;url=http%3A%2F%2Fpinkboy.topobject &#123;name: \"虾莫\", url: \"http://pinkboy.top\"&#125;name: \"虾莫\"url: \"http://pinkboy.top\"__proto__: Object querystring.escape参数编码 12345querystring.escape(\"name=慕白\");/*return:'name%3D%E6%85%95%E7%99%BD'*/ querystring.unescape(str)unescape方法可将含有%的字符串进行解码 12345querystring.unescape('name%3D%E6%85%95%E7%99%BD');/*return:'name=慕白'*/","tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"JS面向对象之创建对象方式与原型链","date":"2018-03-14T06:51:44.691Z","path":"2018/03/14/JS面向对象之创建对象方式与原型链/","text":"本文描述对象的几种常用创建方式以及什么是原型。 工厂模式123456function creatStudent(name,age)&#123; var o=new Object(); o.name=name; o.age=age; return o;&#125; 1stu1=creatStudent('zjn',20); 工厂模式虽然或以创建多个类似的对象，但是却无法识别对象，不知道一个对象是什么类型的。 构造函数模式12345function Student(name,age)&#123; this.name=name; this.age=age;&#125;stu1=new Student('zjn',20); 这个写法改写了工厂模式的那个例子，Person()就是一个构造函数，构造函数应该以大写字母开头。 new一个对象出来经历4个步骤： 创建一个新的对象 将构造函数作用域给新对象(那样this就指向了新对象) 执行构造函数中的代码(给新对象添加属性和方法) 返回新对象上面例子中的stu1对象有一个constructor属性，指向Student. 1alert(stu1.constructor==Student) //true 所以constructor&gt;能够识别对象类型，但用instanceof来检测对象类型更好，上面创造的stu1对象既是Student的实例，也是Object的实例，因为所有的对象都继承自Object对象。 12alert(stu1 instanceof Student) //truealert(stu1 instanceof Object) //true 原型模式像上面的Student这样的构造函数会有一个prototype属性，这个属性指向prototype对象(原型对象)。这个对象包含共享的属性和方法。 123456789101112function Student(name,age)&#123; this.name=name; this.age=age;&#125;Student.prototype.sayName=function()&#123; alert(this.name);&#125;Student.prototype.area='China'stu1=new Student('zjn',20);stu1.sayName();//'zjn'alert(stu1.area);//'China' 在默认情况下，原型对象(prototype对象)会自动获得一个constructor属性，这个属性又指向prototype属性所在的函数，如Student.prototype.constructor就指向Student这个函数本身。 除此之外，原型对象还会有一个proto属性，这个属性指向Object原型对象。 实例化一个对象后，这个实例会有一个proto属性，这个属性指向构造函数的原型对象。比如stu1的proto属性指向Student的原型对象。 按照下图理解 在实例中添加一个原型中已经有的属性，会屏蔽原型中的同名属性。可以用hasOwnProperty()来检测对象上是否有这个属性。 12console.log(stu1.hasOwnProperty('name'));//trueconsole.log(stu1.hasOwnProperty('area'));//false 关于原型重写的问题同样是之前使用的那个例子，如果我们要加原型方法或属性需要不断的写Student.prototype.xxx=xxx,我们可以重写原型来减少体力劳动。 123456789function Student(name,age)&#123; this.name=name; this.age=age;&#125;Student.prototype=&#123; sayname:function()&#123;alert(this.name);&#125;, area:'China'&#125; 这样做有什么问题呢？ 因为我们写了一个prototype的对象，所以它会创建自己的prototype对象，里面的constructor属性将指向Object。也就是本该指向Student的prototype对象中的constructor不再指向Student。 组合使用构造函数模式和原型模式所以要引出这个模式，将有引用类型的属性放到构造函数中，使每个实例都有一个副本，不会相互影响。 12345678910111213function Student(name,age)&#123; this.name=name; this.age=age; teacher=['a','b','c'];&#125;Student.prototype=&#123; constructor:Student, sayName:function()&#123; alert(this.name);&#125;stu1=new Student('zjn',20);stu2=new Student('gcf',20); 本文转自GaNan’s Blog","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JS实现简单的别踩白块游戏","date":"2018-03-14T06:51:44.670Z","path":"2018/03/14/JS实现简单的别踩白块游戏/","text":"界面未作优化 只实现了基本功能 随机生成黑快 点击分数加成 错点以及触底死亡 难度选择等 点击—-查看演示 玩家信息设置开始/暂停 等级选择以及分数统计 12345678910&lt;div class=\"playerInformation\"&gt; &lt;h2&gt;玩家信息 &lt;/h2&gt; &lt;button id=\"Btn1\"&gt;开始&lt;/button&gt; &lt;button id=\"Btn2\"&gt;暂停&lt;/button&gt; &lt;select name=\"\" id=\"selectBtn\"&gt; &lt;option value=\"5\" class=\"rank\"&gt;简单&lt;/option&gt; &lt;option value=\"10\" class=\"rank\"&gt;一般&lt;/option&gt; &lt;option value=\"20\" class=\"rank\"&gt;困难&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 用户操作123456789101112131415startBtn.onclick = function () &#123; clearInterval(timer); timer = setInterval(function () &#123; move(speed); &#125;&#125; stopBtn.onclick = function () &#123;// 暂停 clearInterval(timer); &#125; Select.onchange = function () &#123; // 选择等级 h = -100; //初始化 speed = parseInt(this.value); //改变速度&#125; 移动函数总共五列，初始位置offsetTop=-100px,然后按照设置的速度向下移动。移动的时候 h=0时瞬间把它变成-100 然后慢慢+speed 直到h=0 如此循环 12345678910111213141516171819202122232425function move(speed) &#123; // 下移动一格 offsetTop变成0之后，将原本的最后一个节点插到第一个节点处 playerClick(); if (h == 0) &#123; Content.insertBefore(Content.children[5], Content.children[0]); for (i = 0; i &lt; 4; i++) &#123; Content.children[0].children[i].style.background = \"\"; Content.children[0].children[i].isBlack = 0; &#125; &#125; h == 0 ? h = -100 : h += speed; //这句是关键。移动的时候 h=0时瞬间把它变成-100 然后慢慢+speed 直到h=0 如此循环 Content.style.top = h + 'px'; if (h == -100) &#123; // 黑块触底死亡 for (var i = 0; i &lt; 4; i++) &#123; if (Content.children[5].children[i].isBlack) &#123; clearInterval(timer); alert('死了'); &#125; &#125; creatBlack(); &#125;&#125; 生成黑块函数在第一行的四个格子中随机生成一个黑块12345function creatBlack() &#123; var blackOne = Content.children[0].children[parseInt(Math.random() * 4)]; //随机生成黑块 blackOne.style.background = \"black\"; blackOne.isBlack = 1;&#125; 用户操作function playerClick() { for (i = 0; i &lt; adot.length; i++) { adot[i].index = i; adot[i].onclick = function () { if (this.isBlack == 1) { this.style.background = \"#B0E0E6\"; scoreNum += 10; Score.innerHTML = \"你的得分为：\" + scoreNum + \"分\"; this.isBlack = 0;} else { this.isBlack = 0; scoreNum = 0; alert(\"死了\") } } } } 效果截图 在这个小案例中。要选择contentde 下第一列元素时，忽略了DOM 中的文本节点，使用obj.fistChild()选择 ，结果错误，因为html中的转行符号占了一个空的文本节点。后来改用obj.children[0]解决了。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JS中的继承","date":"2018-03-14T06:51:44.645Z","path":"2018/03/14/JS中的继承/","text":"本文介绍javascript中常用的几种继承方式 1.原型链继承核心：拿父类实例来充当子类原型对象 12345678910111213141516171819function Super()&#123; this.name = 'gcf'; this.arr = [1];&#125;function Sub()&#123; // ...&#125;Sub.prototype = new Super(); // 核心 var sub1 = new Sub(); //实例化var sub2 = new Sub();sub1.name = 'zjn'sub1.arr.push(2);alert(sub1.name); // zjnalert(sub2.name); // gcf alert(sub1.arr); // 1, 2alert(sub2.arr); // 1, 2 //因为是引用类型，在改变sub1的值时候，sub2也改变了 优点：简单容易实现 缺点：1.创建子类实例时，无法向父类构造函数传参2.修改sub1.arr后sub2.arr也变了，因为来自==原型对象的引用属性是所有实例共享的== 2.构造函数实现继承核心：借父类的构造函数来增强子类实例，等于是把父类的==实例属性复制==了一份给子类实例装上了（完全没有用到原型） 123456789101112131415161718192021222324function Super(val)&#123; //构造函数 this.val = val; //属性 this.arr = [1]; this.fun = function()&#123; //方法 alert(\"hello\") &#125;&#125;function Sub(val)&#123; Super.call(this, val); // 核心 // ...&#125; var sub1 = new Sub(1);//实现了传递参数var sub2 = new Sub(2);sub1.arr.push(2);alert(sub1.val); // 1alert(sub2.val); // 2 alert(sub1.arr); // 1, 2 //可以继承引用属性alert(sub2.arr); // 1 alert(sub1.fun === sub2.fun); // false 无法复用函数 每个实例拥有一个新的fun 函数 优点1.解决了子类实例共享父类引用属性的问题2.创建子类实例时，可以向父类构造函数传参 缺点1.只能继承父类的实例属性和方法，不能继承原型属性/方法2.==无法实现函数复用==，每个子类实例都持有一个新的fun函数，太多了就会影响性能(跟上一点一个意思) 3.组合继承(最常用)核心：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点 123456789101112131415161718192021function Super(val)&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数 保证函数可以复用Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub(val)&#123; Super.call(this,val); // 核心 // ...&#125;Sub.prototype = new Super(); // 核心 var sub1 = new Sub(1);var sub2 = new Sub(2);alert(sub1.val) //1alert(sub1.fun === sub2.fun); // true 优点：1.可以继承引用属性2.可以传参3.函数可以复用 缺点：原型上new一个Super后,原型上多了一份Super的实例属性。而Sub实例上的属性屏蔽了原型的上的属性，又是一种内存浪费。不过问题不大，这也是最常用的一种继承方式。 4.寄生组合继承123456789101112131415161718192021222324function creatObj(obj)&#123; var F=function()&#123;&#125; F.prototype=obj; return new F();&#125;function Super()&#123; this.a=1; this.b=[1];&#125;Super.prototype.c=function()&#123; alert(1);&#125;function Sub()&#123; super.call(this);&#125;var proto=creatObj(Super.prototype);proto.constructor=Sub;Sub.prototype=proto;var sub=new Sub(); 优点：完美 缺点：麻烦 参考资料： 重新理解JS的6种继承方式 博客园-JS实现继承的几种方式","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JS中的正则表达式","date":"2018-03-14T06:51:44.642Z","path":"2018/03/14/JS中的正则表达式/","text":"正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式 定义正则表达式1var patt=new RegExp(pattern,modifiers); 或者更简单的方式: 1var patt=/pattern/modifiers; pattern（模式） 描述了表达式的模式 modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配 1.使用构造函数1var reg=new RegExp(\"[1-9]\\d*$\") 2.使用 //1var reg=/[1-9]\\d*$/ 修饰符 i 忽略大小写 g 全局匹配 m 执行对行匹配 方括号方括号用于查找某个范围内的字符： [abc] 查找方括号间的任何字符 [^abc] 查找任何不在方括号中的字符 元字符 \\d 匹配数字 \\w 查找单词 (包括字符和数字) \\s 查找空白字符 \\S查找非空白字符 匹配规则 ==^== 匹配一个输入或一行的开头，/^a/匹配”an A”，而不匹配”An a” ==$== 匹配一个输入或一行的结尾，/a$/匹配”An a”，而不匹配”an A” ==*== 匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa +匹配前面元字符1次或多次，/ba*/将匹配ba,baa,baaa ==?== 匹配前面元字符0次或1次，/ba*/将匹配b,ba ==(x)== 匹配x保存x在名为$1…$9的变量中 ==x|y== 匹配x或y =={n}== 精确匹配n次 =={n,}== 匹配n次以上 =={n,m}== 匹配n-m次 ==[xyz]== 字符集(character set)，匹配这个集合中的任一一个字符(或元字符) ==[^xyz]== 不匹配这个集合中的任何一个字符 ==[\\b]== 匹配一个退格符 ==\\d== 匹配一个字数字符，/\\d/ = /[0-9]/ ==\\D== 匹配一个非字数字符，/\\D/ = /[^0-9]/ ==\\n== 匹配一个换行符 ==\\r== 匹配一个回车符 ==\\s== 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等 ==\\S== 匹配一个非空白字符，等于/[^\\n\\f\\r\\t\\v]/ ==\\w== 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\\w]匹配”$5.98”中的5，等于[a-zA-Z0-9] ==\\W== 匹配一个不可以组成单词的字符，如[\\W]匹配”$5.98”中的$，等于[^a-zA-Z0-9]。 实例1校验登录名：++只能输入5-20个以字母开头、可带数字、“_”、“.”的字串 ++123456function isRegisterUserName(s) &#123; var patrn=/^[a-zA-Z]&#123;1&#125;([a-zA-Z0-9]|[._])&#123;4,19&#125;$/; if (!patrn.exec(s)) return false return true &#125; 2.校验密码：只能输入6-20个字母、数字、下划线123456function isPasswd(s) &#123; var patrn=/^(\\w)&#123;6,20&#125;$/; if (!patrn.exec(s)) return false return true &#125; 3.Email地址的正则表达式：1\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 4.配网址URL的正则表达式：1http://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)? 5.过滤指定的字符 123456789re=/笨蛋|脑残|找家男|/gstr=\"我是笨蛋 你是脑残找家男\"str.replace(re,function(str)&#123; var result=''; for(i=;i&lt;str.length;++)&#123; result+=\"*\"; &#125; return result;&#125;) 6.去除两端的空格1234String.prototype.trim = function() &#123; return this.replace(/(^\\s*)|(\\s*$)/g, \"\"); &#125; 未完待续","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js中7777的同步和异步概念","date":"2018-03-14T06:51:44.633Z","path":"2018/03/14/js中的同步和异步概念/","text":"同步和异步的概念小结 js是单线程的js是一门单线程的语言，这就意味着同一时间中只能做同一件事情，你也许会问，为什么不设置成多线程呢，这样效率不是会更高吗，看一下下面这段话就知道了 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 最基础的异步是setTimeout和setInterval函数console.log(1); setTimeout(function() { console.log(3) }, 0 ); setTimeout(function() { console.log(4) }, 500 ); setTimeout(function() { console.log(5) }, 500 ); console.log(2); 执行上面的代码：控制台将会一次输出1 2 3 4 5输出3 的代码段被延时0ms但还是在2输出之后才输出，这是因为在js中： 在同一程序段中所有其余的代码执行结束后，超时才会发生。所以如果设置了超时，同时执行了需长时间运行的函数，那么在该函数执行完成之前，超时甚至都不会启动。 js中所有任务可以分成两种一种是同步任务（synchronous），另一种是异步任务（asynchronous） 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行 （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 图片转自 c3gen_小胖–js中的同步和异步 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jQuery 学习心得","date":"2018-03-14T06:51:44.623Z","path":"2018/03/14/jQuery 学习心得/","text":"jQuery 语法实例 $(this).hide()演示 jQuery hide() 函数，隐藏当前的 HTML 元素。 $(“#test”).hide() 演示 jQuery hide() 函数，隐藏 id=”test” 的元素 $(“p”).hide()演示 jQuery hide() 函数，隐藏所有 元素。 $(“.test”).hide()演示 jQuery hide() 函数，隐藏所有 class=”test” 的元素jQuery 元素选择器jQuery 使用 CSS 选择器来选取 HTML 元素。 $(“p”) 选取 元素。 $(“p.intro”) 选取所有 class=”intro” 的 元素。 $(“p#demo”) 选取所有 id=”demo” 的 元素 header 1 header 2 语法 描述 $(“p”) 所有 元素 $(“p.intro”) 所有 class=”intro” 的 元素 $(“.intro”) 所有 class=”intro” 的元素 $(“#intro”) id=”intro” 的元素 $(“ul li:first”) 每个 的第一个 元素 $(“[href$=’.jpg’]”) 所有带有以 “.jpg” 结尾的属性值的 href 属性 $(“div#intro .head” id=”intro” 的 元素中的所有 class=”head” 的元素 动画1$(selector).animate(&#123;params&#125;,speed,callback); 必需的 params 参数定义形成动画的 CSS 属性。可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。可选的 callback 参数是动画完成后所执行的函数名称开始滑动 停止滑动 $(document).ready(function(){ $(\"#flip\").click(function(){ $(\"#panel\").slideDown(5000); }); $(\"#stop\").click(function(){ $(\"#panel\").stop(); }); }); Chaining 允许我们在一条语句中允许多个 jQuery 方法（在相同的元素上） $(\"#p1\").css(\"color\",\"red\") .slideUp(2000).slideDown(2000); 获得内容 - text()、html() 以及 val()三个简单实用的用于 DOM 操作的 jQuery 方法： text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值 删除元素/内容如需删除元素和内容，一般可使用以下两个 jQuery 方法： remove() - 删除被选元素（及其子元素） empty() - 从被选元素中删除子元素接受一个参数 可以过滤被删除的元素删除类名为==italic==的p元素 $(\"p\").remove(\".italic\"); jQuery 操作 CSSjQuery 拥有若干进行 CSS 操作的方法。我们将学习下面这些： addClass() - 向被选元素添加一个或多个类 removeClass() - 从被选元素删除一个或多个类 toggleClass() - 对被选元素进行添加/删除类的切换操作css() - 设置或返回样式属性 6.jQuery - 尺寸 width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 2017/7/25更新","tags":[{"name":"jq","slug":"jq","permalink":"http://yoursite.com/tags/jq/"}]},{"title":"javascript中的call()和apply()方法","date":"2018-03-14T06:51:44.613Z","path":"2018/03/14/javascript中的call()和apply()方法/","text":"详细介绍js中的call和apply()方法 call, apply都属于Function.prototype的一个方法,它是JavaScript引擎内在实现的,因为属于Function.prototype,所以每个Function对象实例,也就是每个方法都有call, apply属性.既然作为方法的属性,那它们的使用就当然是针对方法的了.这两个方法是容易混淆的,因为它们的作用一样,只是使用方式不同 相同点:两个方法产生的作用是完全一样的 不同点:方法传递的参数不同 call方法: 语法： 1call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 定义：调用一个对象的一个方法，以另一个对象替换当前对象。 说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法： 语法1apply([thisObj[,argArray]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明： 如果argArray不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 如果没有提供 argArray 和thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传 实例1.用call实现继承 12345678910111213function Person(name)&#123; this.name = name; this.showName = function()&#123; alert(this.name); &#125; &#125; function Cat(name)&#123; Person.call(this, name); &#125; var cat = new Cat(\"Black Cat\"); cat.showName(); //弹出Black Cat cat并没有Showname()的方法 ，用call方法实现了继承 2.改变this的指向 123456789101112131415var obj1 = &#123; name = 'zjn'&#125; var obj2 = &#123; name = 'gcf'&#125;var getName = function()&#123; alert(this.name);&#125; window.name = 'chrome';getName();//弹出\"chrome\"getName.call(obj1);//弹出\"zjn\"getName.call(obj2);//弹出\"gcf\" call, apply方法区别是,从第二个参数起, call方法参数将依次传递给借用的方法作参数, 而apply直接将这些参数放到一个数组中再传递, 最后借用方法的参数列表是一样的.当参数明确时可用call, 当参数不明确时可用apply给合arguments","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"javascript中的 export和export default的区别","date":"2018-03-14T06:51:44.613Z","path":"2018/03/14/javascript中的 export和export default的区别/","text":"答疑解惑，export和export default的区别本文原创地址链接：http://blog.csdn.net/zhou_xiao_cheng/article/details/52759632，未经博主允许不得转载。 相信很多人都使用过export、export default、import，然而它们到底有什么区别呢？在JavaScript ES6中，export与export default均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用，但在一个文件或模块中，export、import可以有多个，export default仅有一个。具体使用：1、 123456//demo1.jsexport const str = 'hello world'export function f(a)&#123; return a+1&#125; 对应的导入方式： 12//demo2.jsimport &#123; str, f &#125; from 'demo1' //也可以分开写两次，导入的时候带花括号 123456//demo1.jsexport default const str = 'hello world'&lt;!-- 对应的导入方式： --&gt;//demo2.jsimport str from 'demo1' //导入的时候没有花括号","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Ie7兼容性小计","date":"2018-03-14T06:51:44.609Z","path":"2018/03/14/Ie7兼容性小计/","text":"介绍ie中的几个常用兼容操作 1.图片在IE7下出现一个框，去掉是加一个img{ border: 0px}2.div 宽度默认是自由扩展的，只有加了float和position：absolute ，它的自由扩展才会失效，可以加个固定宽度width，或者设置position：absolute ; left：0px ; right : 0px; 强行拉宽width:100%不要随便使用，以免和padding border叠加 input里面文字前面需要空出位置，不要用text-indent，IE7会解析错误，用padding-left可保万无一失1&lt;input name=&quot;&quot; type=&quot;text&quot;style=&quot;text-indent:30px&quot; /&gt; 4.Input表单元素 使用时先清除其固有样式属性比如margin：0px padding：0px，如果有表单元素IE7下默认大小不一样，比如复选框，你可以强行加一个宽高写死14px 5.IE7关于input的父级div加margin-left 和float后，margin-left的距离会赋予到input的前面，问题解决是给该input加个div套住1234&lt;div style=\"margin-left:100px;float:left;background:#0066FF; \"&gt;&lt;div&gt;&lt;input name=\"\" type=\"text\" /&gt;&lt;/div&gt;&lt;/div&gt; 6.用float的时候，有多2个以上元素并排，不许这个加了float，那个不加。要全加上 12&lt;div style=”float:left”&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 7.注意UL li 和span的灵活使用，简单的文字编排，用span和结合使用，导航栏和较复杂的栏目才用ul li 8.如果有部分同学写页面无感或者兼容性很难把控，可以先用色块把大局做出来，再慢慢细化 9.宽高不要设置的太随意，尽量以内部元素自动撑开，如果已经写死，要注意内部元素会不会宽高太多撑爆这个外包的div 10.可以把页面大众字体，行距，字体大小，颜色全局控制，以防止页面小部分忘记设字体行距 123body&#123; padding:0px; margin:0px; font-family:微软雅黑; font-size:12px; line-height:18px;&#125; *{} 对页面里每个标签都会影响到和body{}有本质区别 11.用了float后一定要无条件清除浮动 clear：both 12.中文字体起步价是12px,不要写成10，","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Html 5知识点小计","date":"2018-03-14T06:51:44.608Z","path":"2018/03/14/Html 5知识点小计/","text":"html5中的一些常用知识点 一、主要常用的布局标签：1234567891011&lt;header&gt;：页面的头部区域&lt;footer&gt;：页面的脚部区域&lt;nav&gt;：页面导航元素&lt;article&gt;：页面主体区域的一块主体内容&lt;section&gt;：article里面的一段区域内容&lt;aside&gt;：页面主体区域中附属内容&lt;main&gt; 标签规定文档的主要内容。为规范，不要在页面里出现2个 &lt;main&gt; ，不能是以下元素的后代 &lt;footer&gt;、&lt;header&gt; &lt;article&gt;、&lt;aside&gt; &lt;nav&gt;。&lt;menu&gt;页面菜单元素 12&lt;menu&gt;&lt;li&gt;home&lt;/li&gt;&lt;li&gt;home&lt;/li&gt;&lt;li&gt;home&lt;/li&gt;&lt;/menu&gt;&lt;h3&gt; &lt;span&gt; &lt;p&gt; &lt;em&gt; &lt;strong&gt; 二、其他常见备用的H5布局标签和点缀标签1.hgroup 标题标签 1&lt;hgroup&gt;&lt;h2&gt;HTML5简单吗&lt;/h2&gt;&lt;h2&gt;很简单啊&lt;/h2&gt;&lt;/hgroup&gt; 2.address地址标签，一般在footer里包含地址的标签 1&lt;address&gt;住址:杭州西湖区&lt;/address&gt; 3.mark高亮显示 1&lt;mark&gt;H5&lt;/mark&gt; 4.time标签定义日期和时间–可以单独给时间单独设个强调的样式1&lt;time&gt;9:00&lt;/time&gt; 好处：将原来div标签换成新的容易识别的名称标签，叫做标签的语义化，标签语义化的目的就是对搜索引擎友好，结合简洁清晰的布局结构，能更容易被搜索引擎抓取，这种符合搜索引擎收索规则的做法，网站的推广便可以省下不少钱，而且可维护性更高，因为结构清晰,十分易于阅读 1&lt;div&gt;我很有钱&lt;/div&gt; 对于搜索引擎来说，你只是很普通的div屌丝，尽管你真的很有钱。 1&lt;h1&gt;我很有钱&lt;/h1&gt; 搜索引擎知道这个标签里文字重要性，会重点关注你很有钱标签语义化其实就是把你想要表达的东西更容易被搜索引擎理解和重视 三．H5多媒体标签：video、audio、1.Video 视频标签 12345678&lt;video width=\"400\" height=”200” src=\"1.mp4 \" controls=\"controls\" loop=\"loop\" hidden=\"hidden\"/&gt;``` ```html您的浏览器版本过低，请升级浏览器！ &lt;/video&gt;简写：&lt;video src=\"1.swf \" width=\"400\" height=”400” controls autoplay loop /&gt;&lt;/video&gt; autoplay:音频在就绪后自动播放。autoplay=”autoplay” controls: 如果出现该属性，则向用户显示控件，比如播放按钮。 loop: 如果出现该属性，会循环播放 hidden: 隐藏播放界面 支持3种视频格式Ogg MP4 WebM 2.Audio 音频标签 和视频标签一样写法（现在高版本的谷歌或者火狐其实支持性都很好，万一版本低不支持，就用MP4和ogg）下图是低版本的谷歌和火狐可能不支持，其实高版本的支持性都很好；使用2种格式，能几乎兼容所有浏览器，浏览器会自动根据版本播放 123456789101112131415&lt;audio controls autoplay loop hidden /&gt; &lt;source src=\"1.mp4\" type=\"video/mp4\" /&gt;&lt;source src=\"1.ogg\" type=\"video/ogg\" /&gt; &lt;/audio&gt;``` 如果你觉得他默认的插件太丑，想做个自定义的播放器，需要JS的支持 ```jsvar audio = document.getElementById('music1');audio.play();//播放 audio.pause();//暂停 audio.currentTime=0;//停止``` ### 四.HTML5表单 新增默认内容```js&lt;input type=\"text\" placeholder=\"请输入用户名\"/&gt; 新增不能为空属性：1input type=\"text\" required=\"required\" /&gt; Datalist元素有助于提供文本框自动完成特性（自动检索输入） 123456&lt;input type=&quot;text&quot; list=&quot;aa&quot; placeholder=&quot;明星排行榜&quot; /&gt;&lt;datalist id=&quot;aa&quot;&gt;（id名称要与list定义的名称一样） &lt;option label=&quot;Top1&quot; value=&quot;范冰冰&quot;&gt; &lt;option label=&quot;Top2&quot; value=&quot;刘涛&quot;&gt; &lt;option label=&quot;Top3&quot; value=&quot;刘亦菲&quot;&gt;&lt;/datalist&gt; 标签的label属性用于定义一个选项的简短描述 五.新增的表单元素统一写法1&lt;input type=\"color（元素名称）\" name=\"\"&gt; 以下针对移动端的时候，会自动跳出相对应的键盘 12345678910111213颜色选择文本框&lt;input type=\"Color\" name=\"\"&gt;日历选择文本框&lt;input type=\"Date\" name=\"\" required=\"required\"&gt;带时间的日历框&lt;input type=\"Datetime-local\" name=\"\"&gt;输入时间文本框&lt;input type=\"Time\" name=\"\"&gt;输入月份文本框&lt;input type=\"month\" /&gt;输入几周文本框&lt;input type=\"week\" /&gt;邮箱地址文本框&lt;input type=\"Email\" name=\"\"&gt;输入网址文本框&lt;input type=\"Url\" name=\"\"&gt;拖动范围文本框&lt;input type=\"Range\" name=\"\" step=\"1\" value=\"60\" min=\"1\" max=\"100\"&gt;（step代表每次拖动区域，value是默认位置，min和max为可拖动的大区间）数字范围文本框&lt;input type=\"Number\" name=\"\" step=\"2\" value=\"2\" min=\"1\" max=\"5\"&gt;电话号码文本框&lt;input type=\"Tel\" name=\"\"&gt;(移动端会直接跳出号码数字框)&lt;br&gt;搜索栏目文本框&lt;input type=\"Search\" name=\"\"&gt;&lt;br&gt;上传文件文本框&lt;input type=\"file\" name=\"\"&gt;&lt;br&gt; 六．HTML5图形绘制 SVG 指可伸缩矢量图形 (图像在放大或改变尺寸的情况下其图形质量不会有损失） SVG 使用HTML元素绘制的2D图形 SVG 图像可通过样式或JS来控制和修改， SVG 图像可被搜索、索引、脚本化或压缩（比普通图像占空间更小）简单来说，是用HTML创建的矢量图形，类似文字一样可以随意更改其大小和颜色，和PS里做的JPG有本质区别,常用于移动端中 1.针对svg画线—标签 边框色 stroke属性 线的宽度stroke-width 线的端点stroke-linecap 线的两端点方形stroke-linecap=”square” 线的两端点圆形stroke-linecap=”round” 1&lt;svg&gt;&lt;line id=&quot;&quot; x1=&quot;30%&quot; y1=&quot;20&quot; x2=&quot;100&quot; y2=&quot;200&quot; stroke=&quot;#F00&quot; stroke-width=&quot;5&quot;/&gt;&lt;/svg&gt; X1 和Y1来确定第一个端点 X2和Y2确定第2个端点 2.针对svg画圆——标签 使用cx=”” cy=”” 定义圆心 r=”50” - - 定义半径，fill=”red”为圆填充颜色。stroke=”blue” stroke-width=”2”定义圆周线条颜色和宽度 1&lt;svg&gt;&lt;circle id=&quot;&quot; cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; fill=&quot;red&quot; stroke=&quot;blue&quot; stroke-width=&quot;2&quot; /&gt;&lt;/svg&gt; 3.针对svg画椭圆——标签椭圆中心 cx=”120”cy=”60”，X轴半径 rx=”100” Y轴半径 ry=”50”,填充颜色fill，边框宽度stroke-width，边框颜色stroke 1&lt;ellipse cx=&quot;100&quot; cy=&quot;60&quot; rx=&quot;100&quot; ry=&quot;50&quot; fill=&quot;red&quot; stroke=&quot;blue&quot; stroke-width=&quot;2&quot; /&gt; 4.针对svg画矩形—–标签 用 width=”300” height=”100” 定义高宽，填充颜色fill，边框宽度stroke-width， 边框颜色stroke 设置填充色透明度fill-opacity=”0.5” stroke-opacity=”0.5” 1&lt;svg&gt;&lt;rect width=&quot;300&quot; height=&quot;100&quot; stroke=&quot;#17301D&quot; stroke-width=&quot;2&quot; fill=&quot;#0E4E75&quot; fill-opacity=&quot;0.5&quot; stroke-opacity=&quot;0.5&quot;/&gt; &lt;/svg&gt; 5.针对SVG画多边形—标签用point定义几个多边形顶点，方向为顺时针定义了四个顶点(10,10),(20,50),(30,60)，(40,70) 1&lt;svg&gt; &lt;polygon points=&quot;10,10 20,50 30,60 40,70&quot; stroke=&quot;#17301D&quot; stroke-width=&quot;2&quot; fill=&quot;#0E4E75&quot; fill-opacity=&quot;0.5&quot; stroke-opacity=&quot;0.5&quot;/&gt; &lt;/svg&gt; 复杂SVG图形直接在AI里绘制好后另存为SVG, 能生成path(路径)标签，要记得另存SVG的时候，要将图形里的所有路径复合（合并一起），免得生成的path太多，控制起来麻烦，框选所有路径，对象→复合选项→建立， 控制svg颜色宽高边框都可以通过css来控制，但是控制其大小有窍门，必须先设置好视区范围—–viewBox=”x, y, width, height” 定位起始位置x:左上角X坐标，y:左上角Y坐标，width:宽度，height:高度,一般来说XY都设为0 里面的宽高要跟AI里那图标的宽高一模一样，然后在控制swg标签里的宽高即可实现1&lt;svg width=”100px” height=”100px” viewBox=\"0 0 200 200\"&gt; AI里面图标实际宽高是200px200px，用viewbox获取 实际图标显示在html5里面的宽高是100px100px字体图标http://www.iconfont.cn/的制作iconfont常用于移动端，一个正规的移动端的图标往往都是iconfont或SVG图片 Canvas 绘图(实际中工作中用的很少) 1234567&lt;canvas id=\"aa\"&gt;&lt;/canvas&gt;&lt;!--创建画布绘制区域--&gt;&lt;script type=\"text/javascript\"&gt;var canvas=document.getElementById('aa');//声明个变量获取到canvas对象var ctx=canvas.getContext('2d');//获取该canvas的2D绘图环境ctx.fillStyle='#FF0000';//绘制代码：填充红色的背景色ctx.fillRect(0,0,80,100);//绘制代码：绘制一个矩形，起始点坐标为 X=0,Y=0,width=80,height=100&lt;/script&gt; Canvas————–用JS来编写固定的分辨率（和PS里一样的位图图形）根据JS的判断和运算进行动态绘制，绘制可以来回重复，适合于做游戏（游戏中会应用JS对事件的判断确定如何绘制图形） SVG——————-用html编写没有固定的分辨率（和AI里面一样的矢量图形）纯粹的整片图形绘制，最适合带有大型渲染区域的应用程序（比如百度地图）","tags":[{"name":"h5","slug":"h5","permalink":"http://yoursite.com/tags/h5/"}]},{"title":"Git爬坑记（二）-----使用TortoiseGit","date":"2018-03-14T06:51:44.604Z","path":"2018/03/14/Git爬坑记（二）-----使用TortoiseGit/","text":"记录git使用过程中碰到的一些问题 哎呀，贼气，昨天下午写好这篇文章了，结果公司给配置了台新电脑，然后就开始迁移东西。没想到就在这时候云笔记崩溃了，我写好的文章尽然没有同步过来。只能再来一遍了，正好昨天新电脑又装了一遍git,全程零报错，哈哈。。下面见教程。后来发现这个问题好像是有道云笔记的一个bug，出现未知错误时候必须确保ie浏览器能上网，解决了这个问题之后再重新登陆，就OK了。 git生成公私钥这是一篇写的超级详细的教程 点击查看–git: windows git ssh keys生成 第1步：创建SSH Key。在windows下查看[c盘-&gt;用户-&gt;自己的用户名-&gt;.ssh]下是否有id_rsa、id_rsa.pub文件，如果没有需要手动生成。打开git bash，在控制台中输入以下命令。 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果本地存在.ssh 执行上述命令之后会提示是否覆盖，输入yes即可 一般来说，输入以上命令行之后，我们连续按三下空格，因为后续操作是密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。这里使用的是rsa。 同时在密钥中有一个注释字段，用-C来指定所指定的注释，可以方便用户标识这个密钥，指出密钥的用途或其他有用的信息。所以在这里输入自己的邮箱或者其他都行。 输入完毕后程序同时要求输入一个密语字符串(passphrase)，空表示没有密语。接着会让输入2次口令(password)，空表示没有口令。3次回车即可完成当前步骤，此时[c盘&gt;用户&gt;自己的用户名&gt;.ssh]目录下已经生成好了。 第2步：登录github。打开setting-&gt;SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进key输入框中，再为当前的key起一个title来区分每个key。 TortoiseGit使用下载使用 官网下载链接如果嫌弃下载慢的话，也可以点击个人珍藏 汉化版TortoiseGit确保安装好Git之后，先安装tortoisegit，然后安装汉化包。就OK啦。踩坑时间到：弄好之后clone项目 发现报错如下 ：“git did not exit cleanly (exit code 1)”这时候应该右键—&gt;tortoisegit setting—&gt;然后找到network选项，更改配置如下图：","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Git使用爬坑记(一)-----命令行","date":"2018-03-14T06:51:44.599Z","path":"2018/03/14/Git爬坑记（一）------命令行使用/","text":"使用命令行操作 常见的命令行操作本文参考廖雪峰官方网站Git教程 创建仓库 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。-m添加的是描述信息 1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 版本回退1git reset --hard commit_id HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令==git reset –hard commit_id==。 穿梭前，用==git log==可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用==git reflog==查看命令历史，以便确定要回到未来的哪个版本。 暂存在区 我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用==git add==把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用==git commit==提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一==个master==分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改 撤销修改1git checkout --readme.txt 命令==git checkout –readme.txt==意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态 删除文件删除也是修改，删错的时候可以使用撤销修改来还原1rm +filrname 有些废弃文件要删除，一般可以直接在文件资源管理器中删除，当然也可以使用git命令删除执行 == git rm test.txt==现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 或者 删错了，可以使用上面的撤销修改还原 创建远程仓库在github 上面新建一个仓库后按照提示，输入 1git remote add origin git@github.com:XXM-cf/learnGit.git 这个时候可能会跳出提示下main的信息：输入yes即可 123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 把本地库的内容推送到远程，用==git push==命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令 这时候可能会报错，没有公钥，将本地的公钥添加到github 中即可 从远程仓库克隆实际开发的过程中，更多的应该是先创建远程仓库，然后克隆到本地，在github上创建好仓库后在你的项目目录下执行 ==git clone+地址== 就可以克隆下来啦。 创建新的分支Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 解决冲突 当多人协作改变同一个分支的时候，文件内容 就会冲突，此时，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，…冲突的内容…，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存 我们将冲突的地方修改后，重新提交就可以了；","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"git将本地项目与远程仓库连接","date":"2018-03-14T06:51:44.576Z","path":"2018/03/14/Git实现从本地添加项目到远程仓库/","text":"连接远程仓库，使用版本管理。 1.先在github上建立远程仓库， 2.在本地文件夹中 使用git bash进入，新建文件夹， git init 初始化一个仓库， 3.将项目文件拷贝到改目录下， 4.跟远程仓库作连接，复制刚刚创建好仓库时github自动生成的代码就可以 5.git add +文件名 添加项目到文件暂存区 6.git commit -m ‘描述信息’ 提交到分支 7.git push -u origin master 推送代码到远程仓库 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 如果输入$ git remote add origin git@github.com:djqiang（github帐号名）/gitdemo（项目名）.git 提示出错信息：fatal: remote origin already exists.解决办法如下： 1、先输入$ git remote rm origin 2、再输入$ git remote add origin git@github.com:djqiang/gitdemo.git 就不会报错了！ 3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’. 我们需要修改gitconfig文件的内容 4、找到你的github的安装路径，我的是C:\\Users\\ASUS\\AppData\\Local\\GitHub\\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\\etc 5、找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"ES6几个常用的特性","date":"2018-03-14T06:51:44.549Z","path":"2018/03/14/ES6的一些新特性/","text":"介绍ES6中比较常用的几个特性 箭头操作符 它简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。 我们知道在JS中回调是经常的事，而一般回调又以匿名函数的形式出现，每次都需要写一个function，甚是繁琐。当引入箭头操作符后可以方便地写回调了。请看下面的例子 1234567var array = [1, 2, 3];//传统写法array.forEach(function(v, i, a) &#123; console.log(v);&#125;);//ES6array.forEach(v = &gt; console.log(v)); ES6中添加了对类的支持，引入了class关键字（其实class在JavaScript中一直是保留字，目的就是考虑到可能在以后的新版本中会用到，现在终于派上用场了）。JS本身就是面向对象的，ES6中提供的类实际上只是JS原型模式的包装。现在提供原生的class支持后，对象的创建，继承更加直观了，并且父类方法的调用，实例化，静态方法和构造函数等概念都更加形象化 123456789101112131415161718192021222324252627//类的定义class Animal &#123; //ES6中新型构造器 constructor(name) &#123; this.name = name; &#125; //实例方法 sayName() &#123; console.log('My name is '+this.name); &#125;&#125;//类的继承class Programmer extends Animal &#123; constructor(name) &#123; //直接调用父类构造器进行初始化 super(name); &#125; program() &#123; console.log(\"I'm coding...\"); &#125;&#125;//测试我们的类var animal=new Animal('dummy'),wayou=new Programmer('wayou');animal.sayName();//输出 ‘My name is dummy’wayou.sayName();//输出 ‘My name is wayou’wayou.program();//输出 ‘I'm coding...’ 增强的对象字面量 对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在： 可以在对象字面量里面定义原型 定义方法可以不用function关键字 直接调用父类方法 12345678910111213141516//通过对象字面量创建对象var human = &#123; breathe() &#123; console.log('breathing...'); &#125;&#125;;var worker = &#123; __proto__: human, //设置此对象的原型为human,相当于继承human company: 'freelancer', work() &#123; console.log('working...'); &#125;&#125;;human.breathe();//输出 ‘breathing...’//调用继承来的breathe方法worker.breathe();//输出 ‘breathing...’ 字符串模板 字符串模板相对简单易懂些。ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。 1234//产生一个随机数var num=Math.random();//将这个数字输出到consoleconsole.log(`your num is $&#123;num&#125;`); let与const 关键字 可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。 const则很直观，用来定义常量，即无法被更改值的变量。 12for (let i=0;i&lt;2;i++)console.log(i);//输出: 0,1console.log(i);//输出：undefined,严格模式下会报错 for of 值遍历 for in 循环用于遍历数组，类数组或对象，ES6中新引入的for of循环功能相似，不同的是每次循环它提供的不是序号而是值。 12345678910111213141516171819202122232425262728293031323334var someArray = [ \"a\", \"b\", \"c\" ];for (v of someArray) &#123; console.log(v);//输出 a,b,c&#125;//等同于for (i in someArray) &#123; console.log(someArray[i]);//输出 a,b,c&#125;``` ### 模块&gt; 在ES6标准中，JavaScript原生支持module了。这种将JS代码分割成不同功能的小块进行模块化的概念是在一些三方规范中流行起来的，比如CommonJS和AMD模式。&gt; 将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用 ```js// point.jsmodule \"point\" &#123; export class Point &#123; constructor (x, y) &#123; public x = x; public y = y; &#125; &#125;&#125; // myapp.js//声明引用的模块module point from \"/point.js\";//这里可以看出，尽管声明了引用的模块，还是可以通过指定需要的部分进行导入import Point from \"point\"; var origin = new Point(0, 0);console.log(origin); promises Promises是处理异步操作的一种模式，之前在很多三方库中有实现，比如jQuery的deferred 对象。当你发起一个异步请求，并绑定了.when(), .done()等事件处理程序时，其实就是在应用promise模式; 1234567891011121314151617//创建promisevar promise = new Promise(function(resolve, reject) &#123; // 进行一些异步或耗时操作 if ( /*如果成功 */ ) &#123; resolve(\"Stuff worked!\"); &#125; else &#123; reject(Error(\"It broke\")); &#125;&#125;);//绑定处理程序promise.then(function(result) &#123; //promise成功的话会执行这里 console.log(result); // \"Stuff worked!\"&#125;, function(err) &#123; //promise失败会执行这里 console.log(err); // Error: \"It broke\"&#125;); 本文转自—ES6新特性概览","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"css选择器优先级","date":"2018-03-14T06:51:44.538Z","path":"2018/03/14/css选择器优先级/","text":"确定浏览器最终渲染的样式目的：为了解决冲突，确定哪条规则胜出并最终被应用，CSS提供了三种机制：继承、层叠和特指 1.继承CSS 中的祖先元素会向后代传递一样东西：CSS属性的值。可以继承的属性相当一部分都个文本有关，比如颜色、字体、字号。然而，也有很多 CSS 属性不能继承，因为继承这些属性没有意义。这些不能继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距。 注意：由于字体和文本样式是可以继承的，所以在使用相对字体单位（如百分比和 em）时要格外小心。如果某个标签的字体大小被设置为 80%，而它的一个后代的字体大小也被设置为 80%，那么该后代中文本最终的字体大小将是 64%（ 80%的 80%）。这有时候可能并不是你想要的结果。 2.层叠层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。 提示：层叠是 CSS 的核心机制，理解了它才能以最经济的方式写出最容易改动的 CSS，让文档外观在达到设计要求的同时，也给用户留下一些空间，让他们能根据需要更改文档的显示效果（比如整体调整字号）。 2.1 样式来源以下是浏览器层叠各个来源样式的顺序： 浏览器默认样式 用户样式表 作者链接样式表（外部样式，按照它们链接到页 面的先后顺序 作者嵌入样式 (内部样式) 作者行内样式其中，用户 是指有特别需求的用户，例如视障人士，他们可以通过用户样式表，强制浏览器加载的所有网站都以更大的字号，更容易分辨的颜色显示内容。而 作者，就是网页设计师（你）。 浏览器会按照上述顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值的设定。整个检查更新过程结束后，再将每个标签以最终设定的样式显示出来。 2.2 层叠规则 层叠规则一：找到应用给每个元素和属性的所有声明层叠规则二：按照顺序和 权重 排序层叠规则三：按 特指度（specific）排序层叠规则四：顺序决定权重。 提示：声明也可以有权重，空格!important 分号( ;)用于加重声明的权重。例如：p {color:green !important; font-size:12pt;} 3.特指计算选择符的特指度 一个简单的记分规则，即对每个选择符都要按下面的 ICE 公式计算三个值：I-C-E（ID-Class-Element） 说明：1.三个字母间的短横线是分隔符，并非减号；2.这并非真正的三位数，只不过大多数情况下把结果看成一个三位数没问题，三位数最大的胜出。 但是，千万得知道 0-1-12 与 0-2-0 相比，仍然是 0-2-0 的特指度更高。 针对这个公式的计分办法如下：1.选择符中有一个ID，就在I的位置加1；2.选择符中有一个类，就在C的位置加1；3.选择符中有一个元素（标签）名，就在E的位置上加1；4.得到一个三位数。可以通过下面的例子来理解： 123456P&#123;&#125; //0-0-1 特指度=1p.largetext&#123;&#125; //0-1-1 特指度=11p#largetext&#123;&#125; //1-0-1 特指度=101body p#largetext&#123;&#125; //1-0-2 特指度=102body p#largetext ul.mylist&#123;&#125; //1-1-3 特指度=113body p#largetext ul.mylist li&#123;&#125; //1-1-4 特指度=114 在此，每个选择符都比前一个选择符的特指度更高。 4.查理版简单层叠要点在这个查理版里，只要记住三条规则就够了。这三条规则适合所有情况： 规则一： 包含 ID 的选择符胜过包含类的选择符，包含类的选择符胜过包含标签名的选择符。 规则二： 如果几个不同来源都为同一个标签的同一个属性定义了样式，行内样式胜过嵌入样式，嵌入样式胜过链接样式。在链接的样式表中，具有相同特指度的样式，后声明的胜过先声明的。规则一胜过规则二。换句话说，如果选择符更明确（特指度更高），无论它在哪里，都会胜出。 规则三： 设定的样式胜过继承的样式，此时不用考虑特指度（即显式设定优先）。下面简单解释一下规则三。 比如下面的标记： 123&lt;div id=\"cascade_demo\"&gt; &lt;p id=\"inheritance_fact\"&gt;Inheritance is &lt;em&gt;weak&lt;/em&gt; in the Cascade&lt;/p&gt;&lt;/div&gt; 和下面的规则： div#cascade_demo p#inheritance_fact {color:blue;} 2 - 0 - 2 （高特指度）会导致单词 weak 变成蓝色，因为它从父元素 p 那里继承了这个颜色值。 但是，只要我们再给 em 添加一条规则 em {color:red;} 0 - 0 - 1 （低特指度）em 就会变成红色。因为，虽然它的特指度低（0-0-1），但 em 继承的颜色值，会被为它明确（显式）指定的颜色值覆盖，就算（隐式）遗传该颜色值的规则的特指度高（2-0-2）也没有用","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"CSS中的各种居中方法","date":"2018-03-14T06:51:44.514Z","path":"2018/03/14/css各种居中方法/","text":"介绍css中的垂直居中和水平居中的方法 文字居中对于单行文字居中，比较简单设置: 1234567&lt;style&gt;.content&#123;text-align:center;height:100px;line-height:100px;&#125;&lt;/style&gt; 多行文字居中设置包含文字元素的宽高，然后使用绝对定位；适用于子元素知道宽高的，不止是文字，其他块级元素也可以。 1234567891011121314151617181920&lt;style&gt;.wrapper&#123; width:300px; height:300px; border:1px solid black; position:relative;&#125;.content&#123; height:100px; width:1px solid black; postion:absolute; top:50%; margin-top:-50px; left:50%; margin-left:-50px;&#125;&lt;/style&gt;&lt;div class=\"wrapper\"&gt; &lt;p class=\"content\"&gt;居中的文字&lt;/p&gt;&lt;/div&gt; 无宽高图片居中无宽高的行内元素要居中，就有点麻烦了下面介绍几种方法： 使用绝对定位+margin这种方法的原理是，设置子元素为绝对定位，距离父元素上下左右都为0；如果距离不够，自动用margin补充。 1234567891011121314151617&lt;style&gt;#wrapper&#123; position: relative; background: gray; width: 800px; height: 800px; &#125; img &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin:auto; &#125;&lt;/style&gt; button居中法button内容默居中的，所以可以利用这一属性来居中内容这个方法兼容性良好，但是需要禁用Butotn的默认点击事件 12345678910111213141516171819&lt;style&gt; .box &#123; width: 450px; height: 450px; border: 1px solid; background: #333; position: relative; &#125;button &#123; width: 450px; height: 450px; border: 1px solid #fff; background: none;&#125;&lt;/style&gt;&lt;div class=\"box\"&gt;&lt;button disabled=\"true\"&gt;&lt;img src=\"1.png\" alt=\"\"&gt;&lt;/button&gt;&lt;/div&gt; display:table-cell方法设置父元素的 dispaly,但是这个方法有个问题，table-cell需要在标准文档流中才有效，所以如果父元素设置为absolute 或者float之后，此方法无效，另外，兼容性也有问题，IE6、7 并不支持这个样式。12345678910111213141516&lt;style&gt; .box &#123; width: 450px; height: 450px; border: 1px solid; background: #333; position: relative; display:table-cell; vertical-align: middle; text-align: center; &#125; &lt;/style&gt;&lt;div class=\"box\"&gt;&lt;img src=\"1.png\" alt=\"\"&gt;&lt;/div&gt; 定宽块状元素居中满足定宽（块状元素的宽度width为固定值）和块状两个条件的元素可以通过设置“左右margin”值为“auto”来实现居中。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"css中的尺寸","date":"2018-03-14T06:51:44.497Z","path":"2018/03/14/Css中的单位(1)/","text":"简单介绍css中的尺寸 包括PX em vh 等 css中的尺寸1.Px 相对长度单位。像素px是相对于显示器屏幕分辨率而言的2.em 相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。1234567&lt;body&gt;body&lt;div class=\"div1\"&gt;div1 &lt;div class=\"div2\"&gt;div2 &lt;div class=\"div3\"&gt;div3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body 在这个例子中 body的font-size是继承自跟元素html，html的尺寸是浏览器默认尺寸14px； div1的font-size=1.5*14px = 21px; div2的font-size=1.5*21px = 31.5px; div3的font-size=1.5*31.5px = 47.25px; 3.vh and vw： 相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。 1vh 等于1/100的视口高度，1vw 等于1/100的视口宽度。 设置一个和屏幕同宽的标题，h1{font-size:100vw}，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果。 实现与同屏幕等高的框123.box&#123; height:100vh;&#125; 4.vmin and vmax： 关于视口高度和宽度两者的最小值或者最大值。 浏览器的宽度设置为1200px，高度设置为800px， 1vmax = 1200/100px = 12px， 1vmin = 800/100px = 8px 如果宽度设置为600px,高度设置为1080px, 1vmin就等于6px, 1vmax则未10.8px。 chrome强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px,子节点rem的计算还是以12px为基准 text-indent设置抬头距离css缩进 letter-spacing来设置字与字间距_字符间距离，字体间距css样式 参考资料","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"css3 使用伪类创建小箭头、绘制任意形状的三角形","date":"2018-03-14T06:51:44.493Z","path":"2018/03/14/css3 使用伪类创建小箭头、绘制任意形状的三角形/","text":"伪类创建小箭头、绘制任意形状的三角形平时我们经常会用到会话款或者自定义下拉宽的小箭头，处理的时候，专门切图当背景又太麻烦，这时候我们可以利用css3的一些属性，直接写一个div变形之后，就成为我们想要的了。以下是实例：1.使用伪类创建三角形 12345678910111213141516171819202122232425262728&lt;style&gt;.box &#123; width: 100px; height: 100px; background: pink; margin: 50px; position: relative;&#125;&lt;!--使用伪类添加一个div 旋转之后定位到想要放置的地方--&gt;.box:after &#123; content: \"\"; position: absolute; top: -6px; left: 50%; margin-left: -6px; z-index: -1; width: 12px; height: 12px; background: red; transform: rotate(-45deg); -o-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg);&#125;&lt;/style&gt;&lt;!--html结构--&gt;&lt;div class=\"box2\"&gt;1&lt;/div&gt; 效果如图所示 2.绘制三角形 1234567891011121314151617181920&lt;style&gt;.box3 &#123; width: 0; height: 0; border-left: 0px solid transparent; border-right: 50px solid transparent; border-bottom: 50px solid bisque;&#125;.box4 &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 0px solid transparent; border-bottom: 50px solid bisque;&#125;&lt;/style&gt;&lt;div class=\"box3\"&gt;3&lt;/div&gt;&lt;div class=\"box4\"&gt;4&lt;/div&gt; 3.说明：用来指定全透明色彩。 transparent是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。 在CSS1中，transparent被用来作为background-color的一个参数值，用于表示背景透明。 在CSS2中，border-color也开始接受transparent作为参数值，《Open eBook(tm) Publication Structure 1.0.1》[OEB101]延伸到color也接受transparent作为参数值。 在CSS3中，transparent被延伸到任何一个有color值的属性上。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Ajax语法","date":"2017-11-19T14:13:00.000Z","path":"2017/11/19/Ajax相关知识/","text":"AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）工作原理 创建123456789101112131415161718192021222324252627282930313233343536&lt;script&gt;//1创建ajax对象if(window.XMLHttpRequest)&#123; var xhr = new XMLHttpRequest;&#125;else&#123; var xhr = new ActiveXObject('Microsoft.XMLHTTP');//兼容IE6以下版本的浏览器&#125;;//2链接 open()接受三个参数 请求方式 请求地址 是否是异步（同步几乎不用）//get是把请求的数据放到地址栏上 //post是把数据放到send上xhr.open('get','http://test.jgw.com/ajax/test.txt');//3发送xhr.send(); //4接收xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123;//XHR对象的readyState属性表示请求/响应过程的当前活动阶段//1-启动，调用了open()方法，未调用send()方法；//2-发送，已经调用了send()方法，未接收到响应；//3-接收，已经接收到部分响应数据；//4-完成，已经接收到全部响应数据；//readyState的值发生变化就会调用onreadystatechange 事件 if(xhr.status==200)&#123; //status是状态码 200是成功 404是错误 alert(xhr.responseText)//responseText：响应返回的主体内容，为字符串类型 //responseXML &#125;else&#123; alert('错误'+xhr.status) &#125; &#125;&#125; &lt;/script&gt; GET和POSTget1、会把数据放在地址栏上 发送 2、get的安全性能底 3、get的大小是有限制的 PS:get多用于获取数据 post1、不会把数据放在地址里上 2、安全性能高 3、post是没有限制的 PS:多用于发送数据的 GET—-用于获取数据（如：浏览帖子） POST—用于上传数据（如：用户注册 封装ajax12345678910111213141516171819202122&lt;script&gt;function ajax(url, fncus, fner) &#123; var xhr = new XMLHttpRequest; xhr.open('get', url, true); //true代表异步 xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; fncus(xhr.responseText) &#125; else &#123; if (fner) &#123; fner('请求失败，状态码' + xhr.status) &#125; &#125; &#125; &#125;&#125;;ajax('http://test.jgw.com/ajax/data/0.txt', function (data) &#123; console.log(data) //获取成功后打印出data &#125;);&lt;/script&gt;","tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}]}]